{"version":3,"sources":["scripts/crossfilter.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA","file":"crossfilter.c51c6cbb.js","sourceRoot":"..","sourcesContent":["// (function(exports){\n//   crossfilter.version = \"1.3.14\";\n//   function crossfilter_identity(d) {\n//     return d;\n//   }\n//   crossfilter.permute = permute;\n  \n//   function permute(array, index) {\n//     for (var i = 0, n = index.length, copy = new Array(n); i < n; ++i) {\n//       copy[i] = array[index[i]];\n//     }\n//     return copy;\n//   }\n//   var bisect = crossfilter.bisect = bisect_by(crossfilter_identity);\n  \n//   bisect.by = bisect_by;\n  \n//   function bisect_by(f) {\n  \n//     // Locate the insertion point for x in a to maintain sorted order. The\n//     // arguments lo and hi may be used to specify a subset of the array which\n//     // should be considered; by default the entire array is used. If x is already\n//     // present in a, the insertion point will be before (to the left of) any\n//     // existing entries. The return value is suitable for use as the first\n//     // argument to `array.splice` assuming that a is already sorted.\n//     //\n//     // The returned insertion point i partitions the array a into two halves so\n//     // that all v < x for v in a[lo:i] for the left side and all v >= x for v in\n//     // a[i:hi] for the right side.\n//     function bisectLeft(a, x, lo, hi) {\n//       while (lo < hi) {\n//         var mid = lo + hi >>> 1;\n//         if (f(a[mid]) < x) lo = mid + 1;\n//         else hi = mid;\n//       }\n//       return lo;\n//     }\n  \n//     // Similar to bisectLeft, but returns an insertion point which comes after (to\n//     // the right of) any existing entries of x in a.\n//     //\n//     // The returned insertion point i partitions the array into two halves so that\n//     // all v <= x for v in a[lo:i] for the left side and all v > x for v in\n//     // a[i:hi] for the right side.\n//     function bisectRight(a, x, lo, hi) {\n//       while (lo < hi) {\n//         var mid = lo + hi >>> 1;\n//         if (x < f(a[mid])) hi = mid;\n//         else lo = mid + 1;\n//       }\n//       return lo;\n//     }\n  \n//     bisectRight.right = bisectRight;\n//     bisectRight.left = bisectLeft;\n//     return bisectRight;\n//   }\n//   var heap = crossfilter.heap = heap_by(crossfilter_identity);\n  \n//   heap.by = heap_by;\n  \n//   function heap_by(f) {\n  \n//     // Builds a binary heap within the specified array a[lo:hi]. The heap has the\n//     // property such that the parent a[lo+i] is always less than or equal to its\n//     // two children: a[lo+2*i+1] and a[lo+2*i+2].\n//     function heap(a, lo, hi) {\n//       var n = hi - lo,\n//           i = (n >>> 1) + 1;\n//       while (--i > 0) sift(a, i, n, lo);\n//       return a;\n//     }\n  \n//     // Sorts the specified array a[lo:hi] in descending order, assuming it is\n//     // already a heap.\n//     function sort(a, lo, hi) {\n//       var n = hi - lo,\n//           t;\n//       while (--n > 0) t = a[lo], a[lo] = a[lo + n], a[lo + n] = t, sift(a, 1, n, lo);\n//       return a;\n//     }\n  \n//     // Sifts the element a[lo+i-1] down the heap, where the heap is the contiguous\n//     // slice of array a[lo:lo+n]. This method can also be used to update the heap\n//     // incrementally, without incurring the full cost of reconstructing the heap.\n//     function sift(a, i, n, lo) {\n//       var d = a[--lo + i],\n//           x = f(d),\n//           child;\n//       while ((child = i << 1) <= n) {\n//         if (child < n && f(a[lo + child]) > f(a[lo + child + 1])) child++;\n//         if (x <= f(a[lo + child])) break;\n//         a[lo + i] = a[lo + child];\n//         i = child;\n//       }\n//       a[lo + i] = d;\n//     }\n  \n//     heap.sort = sort;\n//     return heap;\n//   }\n//   var heapselect = crossfilter.heapselect = heapselect_by(crossfilter_identity);\n  \n//   heapselect.by = heapselect_by;\n  \n//   function heapselect_by(f) {\n//     var heap = heap_by(f);\n  \n//     // Returns a new array containing the top k elements in the array a[lo:hi].\n//     // The returned array is not sorted, but maintains the heap property. If k is\n//     // greater than hi - lo, then fewer than k elements will be returned. The\n//     // order of elements in a is unchanged by this operation.\n//     function heapselect(a, lo, hi, k) {\n//       var queue = new Array(k = Math.min(hi - lo, k)),\n//           min,\n//           i,\n//           x,\n//           d;\n  \n//       for (i = 0; i < k; ++i) queue[i] = a[lo++];\n//       heap(queue, 0, k);\n  \n//       if (lo < hi) {\n//         min = f(queue[0]);\n//         do {\n//           if (x = f(d = a[lo]) > min) {\n//             queue[0] = d;\n//             min = f(heap(queue, 0, k)[0]);\n//           }\n//         } while (++lo < hi);\n//       }\n  \n//       return queue;\n//     }\n  \n//     return heapselect;\n//   }\n//   var insertionsort = crossfilter.insertionsort = insertionsort_by(crossfilter_identity);\n  \n//   insertionsort.by = insertionsort_by;\n  \n//   function insertionsort_by(f) {\n  \n//     function insertionsort(a, lo, hi) {\n//       for (var i = lo + 1; i < hi; ++i) {\n//         for (var j = i, t = a[i], x = f(t); j > lo && f(a[j - 1]) > x; --j) {\n//           a[j] = a[j - 1];\n//         }\n//         a[j] = t;\n//       }\n//       return a;\n//     }\n  \n//     return insertionsort;\n//   }\n//   // Algorithm designed by Vladimir Yaroslavskiy.\n//   // Implementation based on the Dart project; see lib/dart/LICENSE for details.\n  \n//   var quicksort = crossfilter.quicksort = quicksort_by(crossfilter_identity);\n  \n//   quicksort.by = quicksort_by;\n  \n//   function quicksort_by(f) {\n//     var insertionsort = insertionsort_by(f);\n  \n//     function sort(a, lo, hi) {\n//       return (hi - lo < quicksort_sizeThreshold\n//           ? insertionsort\n//           : quicksort)(a, lo, hi);\n//     }\n  \n//     function quicksort(a, lo, hi) {\n//       // Compute the two pivots by looking at 5 elements.\n//       var sixth = (hi - lo) / 6 | 0,\n//           i1 = lo + sixth,\n//           i5 = hi - 1 - sixth,\n//           i3 = lo + hi - 1 >> 1,  // The midpoint.\n//           i2 = i3 - sixth,\n//           i4 = i3 + sixth;\n  \n//       var e1 = a[i1], x1 = f(e1),\n//           e2 = a[i2], x2 = f(e2),\n//           e3 = a[i3], x3 = f(e3),\n//           e4 = a[i4], x4 = f(e4),\n//           e5 = a[i5], x5 = f(e5);\n  \n//       var t;\n  \n//       // Sort the selected 5 elements using a sorting network.\n//       if (x1 > x2) t = e1, e1 = e2, e2 = t, t = x1, x1 = x2, x2 = t;\n//       if (x4 > x5) t = e4, e4 = e5, e5 = t, t = x4, x4 = x5, x5 = t;\n//       if (x1 > x3) t = e1, e1 = e3, e3 = t, t = x1, x1 = x3, x3 = t;\n//       if (x2 > x3) t = e2, e2 = e3, e3 = t, t = x2, x2 = x3, x3 = t;\n//       if (x1 > x4) t = e1, e1 = e4, e4 = t, t = x1, x1 = x4, x4 = t;\n//       if (x3 > x4) t = e3, e3 = e4, e4 = t, t = x3, x3 = x4, x4 = t;\n//       if (x2 > x5) t = e2, e2 = e5, e5 = t, t = x2, x2 = x5, x5 = t;\n//       if (x2 > x3) t = e2, e2 = e3, e3 = t, t = x2, x2 = x3, x3 = t;\n//       if (x4 > x5) t = e4, e4 = e5, e5 = t, t = x4, x4 = x5, x5 = t;\n  \n//       var pivot1 = e2, pivotValue1 = x2,\n//           pivot2 = e4, pivotValue2 = x4;\n  \n//       // e2 and e4 have been saved in the pivot variables. They will be written\n//       // back, once the partitioning is finished.\n//       a[i1] = e1;\n//       a[i2] = a[lo];\n//       a[i3] = e3;\n//       a[i4] = a[hi - 1];\n//       a[i5] = e5;\n  \n//       var less = lo + 1,   // First element in the middle partition.\n//           great = hi - 2;  // Last element in the middle partition.\n  \n//       // Note that for value comparison, <, <=, >= and > coerce to a primitive via\n//       // Object.prototype.valueOf; == and === do not, so in order to be consistent\n//       // with natural order (such as for Date objects), we must do two compares.\n//       var pivotsEqual = pivotValue1 <= pivotValue2 && pivotValue1 >= pivotValue2;\n//       if (pivotsEqual) {\n  \n//         // Degenerated case where the partitioning becomes a dutch national flag\n//         // problem.\n//         //\n//         // [ |  < pivot  | == pivot | unpartitioned | > pivot  | ]\n//         //  ^             ^          ^             ^            ^\n//         // left         less         k           great         right\n//         //\n//         // a[left] and a[right] are undefined and are filled after the\n//         // partitioning.\n//         //\n//         // Invariants:\n//         //   1) for x in ]left, less[ : x < pivot.\n//         //   2) for x in [less, k[ : x == pivot.\n//         //   3) for x in ]great, right[ : x > pivot.\n//         for (var k = less; k <= great; ++k) {\n//           var ek = a[k], xk = f(ek);\n//           if (xk < pivotValue1) {\n//             if (k !== less) {\n//               a[k] = a[less];\n//               a[less] = ek;\n//             }\n//             ++less;\n//           } else if (xk > pivotValue1) {\n  \n//             // Find the first element <= pivot in the range [k - 1, great] and\n//             // put [:ek:] there. We know that such an element must exist:\n//             // When k == less, then el3 (which is equal to pivot) lies in the\n//             // interval. Otherwise a[k - 1] == pivot and the search stops at k-1.\n//             // Note that in the latter case invariant 2 will be violated for a\n//             // short amount of time. The invariant will be restored when the\n//             // pivots are put into their final positions.\n//             while (true) {\n//               var greatValue = f(a[great]);\n//               if (greatValue > pivotValue1) {\n//                 great--;\n//                 // This is the only location in the while-loop where a new\n//                 // iteration is started.\n//                 continue;\n//               } else if (greatValue < pivotValue1) {\n//                 // Triple exchange.\n//                 a[k] = a[less];\n//                 a[less++] = a[great];\n//                 a[great--] = ek;\n//                 break;\n//               } else {\n//                 a[k] = a[great];\n//                 a[great--] = ek;\n//                 // Note: if great < k then we will exit the outer loop and fix\n//                 // invariant 2 (which we just violated).\n//                 break;\n//               }\n//             }\n//           }\n//         }\n//       } else {\n  \n//         // We partition the list into three parts:\n//         //  1. < pivot1\n//         //  2. >= pivot1 && <= pivot2\n//         //  3. > pivot2\n//         //\n//         // During the loop we have:\n//         // [ | < pivot1 | >= pivot1 && <= pivot2 | unpartitioned  | > pivot2  | ]\n//         //  ^            ^                        ^              ^             ^\n//         // left         less                     k              great        right\n//         //\n//         // a[left] and a[right] are undefined and are filled after the\n//         // partitioning.\n//         //\n//         // Invariants:\n//         //   1. for x in ]left, less[ : x < pivot1\n//         //   2. for x in [less, k[ : pivot1 <= x && x <= pivot2\n//         //   3. for x in ]great, right[ : x > pivot2\n//         for (var k = less; k <= great; k++) {\n//           var ek = a[k], xk = f(ek);\n//           if (xk < pivotValue1) {\n//             if (k !== less) {\n//               a[k] = a[less];\n//               a[less] = ek;\n//             }\n//             ++less;\n//           } else {\n//             if (xk > pivotValue2) {\n//               while (true) {\n//                 var greatValue = f(a[great]);\n//                 if (greatValue > pivotValue2) {\n//                   great--;\n//                   if (great < k) break;\n//                   // This is the only location inside the loop where a new\n//                   // iteration is started.\n//                   continue;\n//                 } else {\n//                   // a[great] <= pivot2.\n//                   if (greatValue < pivotValue1) {\n//                     // Triple exchange.\n//                     a[k] = a[less];\n//                     a[less++] = a[great];\n//                     a[great--] = ek;\n//                   } else {\n//                     // a[great] >= pivot1.\n//                     a[k] = a[great];\n//                     a[great--] = ek;\n//                   }\n//                   break;\n//                 }\n//               }\n//             }\n//           }\n//         }\n//       }\n  \n//       // Move pivots into their final positions.\n//       // We shrunk the list from both sides (a[left] and a[right] have\n//       // meaningless values in them) and now we move elements from the first\n//       // and third partition into these locations so that we can store the\n//       // pivots.\n//       a[lo] = a[less - 1];\n//       a[less - 1] = pivot1;\n//       a[hi - 1] = a[great + 1];\n//       a[great + 1] = pivot2;\n  \n//       // The list is now partitioned into three partitions:\n//       // [ < pivot1   | >= pivot1 && <= pivot2   |  > pivot2   ]\n//       //  ^            ^                        ^             ^\n//       // left         less                     great        right\n  \n//       // Recursive descent. (Don't include the pivot values.)\n//       sort(a, lo, less - 1);\n//       sort(a, great + 2, hi);\n  \n//       if (pivotsEqual) {\n//         // All elements in the second partition are equal to the pivot. No\n//         // need to sort them.\n//         return a;\n//       }\n  \n//       // In theory it should be enough to call _doSort recursively on the second\n//       // partition.\n//       // The Android source however removes the pivot elements from the recursive\n//       // call if the second partition is too large (more than 2/3 of the list).\n//       if (less < i1 && great > i5) {\n//         var lessValue, greatValue;\n//         while ((lessValue = f(a[less])) <= pivotValue1 && lessValue >= pivotValue1) ++less;\n//         while ((greatValue = f(a[great])) <= pivotValue2 && greatValue >= pivotValue2) --great;\n  \n//         // Copy paste of the previous 3-way partitioning with adaptions.\n//         //\n//         // We partition the list into three parts:\n//         //  1. == pivot1\n//         //  2. > pivot1 && < pivot2\n//         //  3. == pivot2\n//         //\n//         // During the loop we have:\n//         // [ == pivot1 | > pivot1 && < pivot2 | unpartitioned  | == pivot2 ]\n//         //              ^                      ^              ^\n//         //            less                     k              great\n//         //\n//         // Invariants:\n//         //   1. for x in [ *, less[ : x == pivot1\n//         //   2. for x in [less, k[ : pivot1 < x && x < pivot2\n//         //   3. for x in ]great, * ] : x == pivot2\n//         for (var k = less; k <= great; k++) {\n//           var ek = a[k], xk = f(ek);\n//           if (xk <= pivotValue1 && xk >= pivotValue1) {\n//             if (k !== less) {\n//               a[k] = a[less];\n//               a[less] = ek;\n//             }\n//             less++;\n//           } else {\n//             if (xk <= pivotValue2 && xk >= pivotValue2) {\n//               while (true) {\n//                 var greatValue = f(a[great]);\n//                 if (greatValue <= pivotValue2 && greatValue >= pivotValue2) {\n//                   great--;\n//                   if (great < k) break;\n//                   // This is the only location inside the loop where a new\n//                   // iteration is started.\n//                   continue;\n//                 } else {\n//                   // a[great] < pivot2.\n//                   if (greatValue < pivotValue1) {\n//                     // Triple exchange.\n//                     a[k] = a[less];\n//                     a[less++] = a[great];\n//                     a[great--] = ek;\n//                   } else {\n//                     // a[great] == pivot1.\n//                     a[k] = a[great];\n//                     a[great--] = ek;\n//                   }\n//                   break;\n//                 }\n//               }\n//             }\n//           }\n//         }\n//       }\n  \n//       // The second partition has now been cleared of pivot elements and looks\n//       // as follows:\n//       // [  *  |  > pivot1 && < pivot2  | * ]\n//       //        ^                      ^\n//       //       less                  great\n//       // Sort the second partition using recursive descent.\n  \n//       // The second partition looks as follows:\n//       // [  *  |  >= pivot1 && <= pivot2  | * ]\n//       //        ^                        ^\n//       //       less                    great\n//       // Simply sort it by recursive descent.\n  \n//       return sort(a, less, great + 1);\n//     }\n  \n//     return sort;\n//   }\n  \n//   var quicksort_sizeThreshold = 32;\n//   var crossfilter_array8 = crossfilter_arrayUntyped,\n//       crossfilter_array16 = crossfilter_arrayUntyped,\n//       crossfilter_array32 = crossfilter_arrayUntyped,\n//       crossfilter_arrayLengthen = crossfilter_arrayLengthenUntyped,\n//       crossfilter_arrayWiden = crossfilter_arrayWidenUntyped;\n  \n//   if (typeof Uint8Array !== \"undefined\") {\n//     crossfilter_array8 = function(n) { return new Uint8Array(n); };\n//     crossfilter_array16 = function(n) { return new Uint16Array(n); };\n//     crossfilter_array32 = function(n) { return new Uint32Array(n); };\n  \n//     crossfilter_arrayLengthen = function(array, length) {\n//       if (array.length >= length) return array;\n//       var copy = new array.constructor(length);\n//       copy.set(array);\n//       return copy;\n//     };\n  \n//     crossfilter_arrayWiden = function(array, width) {\n//       var copy;\n//       switch (width) {\n//         case 16: copy = crossfilter_array16(array.length); break;\n//         case 32: copy = crossfilter_array32(array.length); break;\n//         default: throw new Error(\"invalid array width!\");\n//       }\n//       copy.set(array);\n//       return copy;\n//     };\n//   }\n  \n//   function crossfilter_arrayUntyped(n) {\n//     var array = new Array(n), i = -1;\n//     while (++i < n) array[i] = 0;\n//     return array;\n//   }\n  \n//   function crossfilter_arrayLengthenUntyped(array, length) {\n//     var n = array.length;\n//     while (n < length) array[n++] = 0;\n//     return array;\n//   }\n  \n//   function crossfilter_arrayWidenUntyped(array, width) {\n//     if (width > 32) throw new Error(\"invalid array width!\");\n//     return array;\n//   }\n//   function crossfilter_filterExact(bisect, value) {\n//     return function(values) {\n//       var n = values.length;\n//       return [bisect.left(values, value, 0, n), bisect.right(values, value, 0, n)];\n//     };\n//   }\n  \n//   function crossfilter_filterRange(bisect, range) {\n//     var min = range[0],\n//         max = range[1];\n//     return function(values) {\n//       var n = values.length;\n//       return [bisect.left(values, min, 0, n), bisect.left(values, max, 0, n)];\n//     };\n//   }\n  \n//   function crossfilter_filterAll(values) {\n//     return [0, values.length];\n//   }\n//   function crossfilter_null() {\n//     return null;\n//   }\n//   function crossfilter_zero() {\n//     return 0;\n//   }\n//   function crossfilter_reduceIncrement(p) {\n//     return p + 1;\n//   }\n  \n//   function crossfilter_reduceDecrement(p) {\n//     return p - 1;\n//   }\n  \n//   function crossfilter_reduceAdd(f) {\n//     return function(p, v) {\n//       return p + +f(v);\n//     };\n//   }\n  \n//   function crossfilter_reduceSubtract(f) {\n//     return function(p, v) {\n//       return p - f(v);\n//     };\n//   }\n//   exports.crossfilter = crossfilter;\n  \n//   function crossfilter() {\n//     var crossfilter = {\n//       add: add,\n//       remove: removeData,\n//       dimension: dimension,\n//       groupAll: groupAll,\n//       size: size\n//     };\n  \n//     var data = [], // the records\n//         n = 0, // the number of records; data.length\n//         m = 0, // a bit mask representing which dimensions are in use\n//         M = 8, // number of dimensions that can fit in `filters`\n//         filters = crossfilter_array8(0), // M bits per record; 1 is filtered out\n//         filterListeners = [], // when the filters change\n//         dataListeners = [], // when data is added\n//         removeDataListeners = []; // when data is removed\n  \n//     // Adds the specified new records to this crossfilter.\n//     function add(newData) {\n//       var n0 = n,\n//           n1 = newData.length;\n  \n//       // If there's actually new data to add…\n//       // Merge the new data into the existing data.\n//       // Lengthen the filter bitset to handle the new records.\n//       // Notify listeners (dimensions and groups) that new data is available.\n//       if (n1) {\n//         data = data.concat(newData);\n//         filters = crossfilter_arrayLengthen(filters, n += n1);\n//         dataListeners.forEach(function(l) { l(newData, n0, n1); });\n//       }\n  \n//       return crossfilter;\n//     }\n  \n//     // Removes all records that match the current filters.\n//     function removeData() {\n//       var newIndex = crossfilter_index(n, n),\n//           removed = [];\n//       for (var i = 0, j = 0; i < n; ++i) {\n//         if (filters[i]) newIndex[i] = j++;\n//         else removed.push(i);\n//       }\n  \n//       // Remove all matching records from groups.\n//       filterListeners.forEach(function(l) { l(0, [], removed); });\n  \n//       // Update indexes.\n//       removeDataListeners.forEach(function(l) { l(newIndex); });\n  \n//       // Remove old filters and data by overwriting.\n//       for (var i = 0, j = 0, k; i < n; ++i) {\n//         if (k = filters[i]) {\n//           if (i !== j) filters[j] = k, data[j] = data[i];\n//           ++j;\n//         }\n//       }\n//       data.length = j;\n//       while (n > j) filters[--n] = 0;\n//     }\n  \n//     // Adds a new dimension with the specified value accessor function.\n//     function dimension(value) {\n//       var dimension = {\n//         filter: filter,\n//         filterExact: filterExact,\n//         filterRange: filterRange,\n//         filterFunction: filterFunction,\n//         filterAll: filterAll,\n//         top: top,\n//         bottom: bottom,\n//         group: group,\n//         groupAll: groupAll,\n//         dispose: dispose,\n//         remove: dispose // for backwards-compatibility\n//       };\n  \n//       var one = ~m & -~m, // lowest unset bit as mask, e.g., 00001000\n//           zero = ~one, // inverted one, e.g., 11110111\n//           values, // sorted, cached array\n//           index, // value rank ↦ object id\n//           newValues, // temporary array storing newly-added values\n//           newIndex, // temporary array storing newly-added index\n//           sort = quicksort_by(function(i) { return newValues[i]; }),\n//           refilter = crossfilter_filterAll, // for recomputing filter\n//           refilterFunction, // the custom filter function in use\n//           indexListeners = [], // when data is added\n//           dimensionGroups = [],\n//           lo0 = 0,\n//           hi0 = 0;\n  \n//       // Updating a dimension is a two-stage process. First, we must update the\n//       // associated filters for the newly-added records. Once all dimensions have\n//       // updated their filters, the groups are notified to update.\n//       dataListeners.unshift(preAdd);\n//       dataListeners.push(postAdd);\n  \n//       removeDataListeners.push(removeData);\n  \n//       // Incorporate any existing data into this dimension, and make sure that the\n//       // filter bitset is wide enough to handle the new dimension.\n//       m |= one;\n//       if (M >= 32 ? !one : m & -(1 << M)) {\n//         filters = crossfilter_arrayWiden(filters, M <<= 1);\n//       }\n//       preAdd(data, 0, n);\n//       postAdd(data, 0, n);\n  \n//       // Incorporates the specified new records into this dimension.\n//       // This function is responsible for updating filters, values, and index.\n//       function preAdd(newData, n0, n1) {\n  \n//         // Permute new values into natural order using a sorted index.\n//         newValues = newData.map(value);\n//         newIndex = sort(crossfilter_range(n1), 0, n1);\n//         newValues = permute(newValues, newIndex);\n  \n//         // Bisect newValues to determine which new records are selected.\n//         var bounds = refilter(newValues), lo1 = bounds[0], hi1 = bounds[1], i;\n//         if (refilterFunction) {\n//           for (i = 0; i < n1; ++i) {\n//             if (!refilterFunction(newValues[i], i)) filters[newIndex[i] + n0] |= one;\n//           }\n//         } else {\n//           for (i = 0; i < lo1; ++i) filters[newIndex[i] + n0] |= one;\n//           for (i = hi1; i < n1; ++i) filters[newIndex[i] + n0] |= one;\n//         }\n  \n//         // If this dimension previously had no data, then we don't need to do the\n//         // more expensive merge operation; use the new values and index as-is.\n//         if (!n0) {\n//           values = newValues;\n//           index = newIndex;\n//           lo0 = lo1;\n//           hi0 = hi1;\n//           return;\n//         }\n  \n//         var oldValues = values,\n//             oldIndex = index,\n//             i0 = 0,\n//             i1 = 0;\n  \n//         // Otherwise, create new arrays into which to merge new and old.\n//         values = new Array(n);\n//         index = crossfilter_index(n, n);\n  \n//         // Merge the old and new sorted values, and old and new index.\n//         for (i = 0; i0 < n0 && i1 < n1; ++i) {\n//           if (oldValues[i0] < newValues[i1]) {\n//             values[i] = oldValues[i0];\n//             index[i] = oldIndex[i0++];\n//           } else {\n//             values[i] = newValues[i1];\n//             index[i] = newIndex[i1++] + n0;\n//           }\n//         }\n  \n//         // Add any remaining old values.\n//         for (; i0 < n0; ++i0, ++i) {\n//           values[i] = oldValues[i0];\n//           index[i] = oldIndex[i0];\n//         }\n  \n//         // Add any remaining new values.\n//         for (; i1 < n1; ++i1, ++i) {\n//           values[i] = newValues[i1];\n//           index[i] = newIndex[i1] + n0;\n//         }\n  \n//         // Bisect again to recompute lo0 and hi0.\n//         bounds = refilter(values), lo0 = bounds[0], hi0 = bounds[1];\n//       }\n  \n//       // When all filters have updated, notify index listeners of the new values.\n//       function postAdd(newData, n0, n1) {\n//         indexListeners.forEach(function(l) { l(newValues, newIndex, n0, n1); });\n//         newValues = newIndex = null;\n//       }\n  \n//       function removeData(reIndex) {\n//         for (var i = 0, j = 0, k; i < n; ++i) {\n//           if (filters[k = index[i]]) {\n//             if (i !== j) values[j] = values[i];\n//             index[j] = reIndex[k];\n//             ++j;\n//           }\n//         }\n//         values.length = j;\n//         while (j < n) index[j++] = 0;\n  \n//         // Bisect again to recompute lo0 and hi0.\n//         var bounds = refilter(values);\n//         lo0 = bounds[0], hi0 = bounds[1];\n//       }\n  \n//       // Updates the selected values based on the specified bounds [lo, hi].\n//       // This implementation is used by all the public filter methods.\n//       function filterIndexBounds(bounds) {\n//         var lo1 = bounds[0],\n//             hi1 = bounds[1];\n  \n//         if (refilterFunction) {\n//           refilterFunction = null;\n//           filterIndexFunction(function(d, i) { return lo1 <= i && i < hi1; });\n//           lo0 = lo1;\n//           hi0 = hi1;\n//           return dimension;\n//         }\n  \n//         var i,\n//             j,\n//             k,\n//             added = [],\n//             removed = [];\n  \n//         // Fast incremental update based on previous lo index.\n//         if (lo1 < lo0) {\n//           for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n//             filters[k = index[i]] ^= one;\n//             added.push(k);\n//           }\n//         } else if (lo1 > lo0) {\n//           for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n//             filters[k = index[i]] ^= one;\n//             removed.push(k);\n//           }\n//         }\n  \n//         // Fast incremental update based on previous hi index.\n//         if (hi1 > hi0) {\n//           for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n//             filters[k = index[i]] ^= one;\n//             added.push(k);\n//           }\n//         } else if (hi1 < hi0) {\n//           for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n//             filters[k = index[i]] ^= one;\n//             removed.push(k);\n//           }\n//         }\n  \n//         lo0 = lo1;\n//         hi0 = hi1;\n//         filterListeners.forEach(function(l) { l(one, added, removed); });\n//         return dimension;\n//       }\n  \n//       // Filters this dimension using the specified range, value, or null.\n//       // If the range is null, this is equivalent to filterAll.\n//       // If the range is an array, this is equivalent to filterRange.\n//       // Otherwise, this is equivalent to filterExact.\n//       function filter(range) {\n//         return range == null\n//             ? filterAll() : Array.isArray(range)\n//             ? filterRange(range) : typeof range === \"function\"\n//             ? filterFunction(range)\n//             : filterExact(range);\n//       }\n  \n//       // Filters this dimension to select the exact value.\n//       function filterExact(value) {\n//         return filterIndexBounds((refilter = crossfilter_filterExact(bisect, value))(values));\n//       }\n  \n//       // Filters this dimension to select the specified range [lo, hi].\n//       // The lower bound is inclusive, and the upper bound is exclusive.\n//       function filterRange(range) {\n//         return filterIndexBounds((refilter = crossfilter_filterRange(bisect, range))(values));\n//       }\n  \n//       // Clears any filters on this dimension.\n//       function filterAll() {\n//         return filterIndexBounds((refilter = crossfilter_filterAll)(values));\n//       }\n  \n//       // Filters this dimension using an arbitrary function.\n//       function filterFunction(f) {\n//         refilter = crossfilter_filterAll;\n  \n//         filterIndexFunction(refilterFunction = f);\n  \n//         lo0 = 0;\n//         hi0 = n;\n  \n//         return dimension;\n//       }\n  \n//       function filterIndexFunction(f) {\n//         var i,\n//             k,\n//             x,\n//             added = [],\n//             removed = [];\n  \n//         for (i = 0; i < n; ++i) {\n//           if (!(filters[k = index[i]] & one) ^ !!(x = f(values[i], i))) {\n//             if (x) filters[k] &= zero, added.push(k);\n//             else filters[k] |= one, removed.push(k);\n//           }\n//         }\n//         filterListeners.forEach(function(l) { l(one, added, removed); });\n//       }\n  \n//       // Returns the top K selected records based on this dimension's order.\n//       // Note: observes this dimension's filter, unlike group and groupAll.\n//       function top(k) {\n//         var array = [],\n//             i = hi0,\n//             j;\n  \n//         while (--i >= lo0 && k > 0) {\n//           if (!filters[j = index[i]]) {\n//             array.push(data[j]);\n//             --k;\n//           }\n//         }\n  \n//         return array;\n//       }\n  \n//       // Returns the bottom K selected records based on this dimension's order.\n//       // Note: observes this dimension's filter, unlike group and groupAll.\n//       function bottom(k) {\n//         var array = [],\n//             i = lo0,\n//             j;\n  \n//         while (i < hi0 && k > 0) {\n//           if (!filters[j = index[i]]) {\n//             array.push(data[j]);\n//             --k;\n//           }\n//           i++;\n//         }\n  \n//         return array;\n//       }\n  \n//       // Adds a new group to this dimension, using the specified key function.\n//       function group(key) {\n//         var group = {\n//           top: top,\n//           all: all,\n//           reduce: reduce,\n//           reduceCount: reduceCount,\n//           reduceSum: reduceSum,\n//           order: order,\n//           orderNatural: orderNatural,\n//           size: size,\n//           dispose: dispose,\n//           remove: dispose // for backwards-compatibility\n//         };\n  \n//         // Ensure that this group will be removed when the dimension is removed.\n//         dimensionGroups.push(group);\n  \n//         var groups, // array of {key, value}\n//             groupIndex, // object id ↦ group id\n//             groupWidth = 8,\n//             groupCapacity = crossfilter_capacity(groupWidth),\n//             k = 0, // cardinality\n//             select,\n//             heap,\n//             reduceAdd,\n//             reduceRemove,\n//             reduceInitial,\n//             update = crossfilter_null,\n//             reset = crossfilter_null,\n//             resetNeeded = true,\n//             groupAll = key === crossfilter_null;\n  \n//         if (arguments.length < 1) key = crossfilter_identity;\n  \n//         // The group listens to the crossfilter for when any dimension changes, so\n//         // that it can update the associated reduce values. It must also listen to\n//         // the parent dimension for when data is added, and compute new keys.\n//         filterListeners.push(update);\n//         indexListeners.push(add);\n//         removeDataListeners.push(removeData);\n  \n//         // Incorporate any existing data into the grouping.\n//         add(values, index, 0, n);\n  \n//         // Incorporates the specified new values into this group.\n//         // This function is responsible for updating groups and groupIndex.\n//         function add(newValues, newIndex, n0, n1) {\n//           var oldGroups = groups,\n//               reIndex = crossfilter_index(k, groupCapacity),\n//               add = reduceAdd,\n//               initial = reduceInitial,\n//               k0 = k, // old cardinality\n//               i0 = 0, // index of old group\n//               i1 = 0, // index of new record\n//               j, // object id\n//               g0, // old group\n//               x0, // old key\n//               x1, // new key\n//               g, // group to add\n//               x; // key of group to add\n  \n//           // If a reset is needed, we don't need to update the reduce values.\n//           if (resetNeeded) add = initial = crossfilter_null;\n  \n//           // Reset the new groups (k is a lower bound).\n//           // Also, make sure that groupIndex exists and is long enough.\n//           groups = new Array(k), k = 0;\n//           groupIndex = k0 > 1 ? crossfilter_arrayLengthen(groupIndex, n) : crossfilter_index(n, groupCapacity);\n  \n//           // Get the first old key (x0 of g0), if it exists.\n//           if (k0) x0 = (g0 = oldGroups[0]).key;\n  \n//           // Find the first new key (x1), skipping NaN keys.\n//           while (i1 < n1 && !((x1 = key(newValues[i1])) >= x1)) ++i1;\n  \n//           // While new keys remain…\n//           while (i1 < n1) {\n  \n//             // Determine the lesser of the two current keys; new and old.\n//             // If there are no old keys remaining, then always add the new key.\n//             if (g0 && x0 <= x1) {\n//               g = g0, x = x0;\n  \n//               // Record the new index of the old group.\n//               reIndex[i0] = k;\n  \n//               // Retrieve the next old key.\n//               if (g0 = oldGroups[++i0]) x0 = g0.key;\n//             } else {\n//               g = {key: x1, value: initial()}, x = x1;\n//             }\n  \n//             // Add the lesser group.\n//             groups[k] = g;\n  \n//             // Add any selected records belonging to the added group, while\n//             // advancing the new key and populating the associated group index.\n//             while (!(x1 > x)) {\n//               groupIndex[j = newIndex[i1] + n0] = k;\n//               if (!(filters[j] & zero)) g.value = add(g.value, data[j]);\n//               if (++i1 >= n1) break;\n//               x1 = key(newValues[i1]);\n//             }\n  \n//             groupIncrement();\n//           }\n  \n//           // Add any remaining old groups that were greater than all new keys.\n//           // No incremental reduce is needed; these groups have no new records.\n//           // Also record the new index of the old group.\n//           while (i0 < k0) {\n//             groups[reIndex[i0] = k] = oldGroups[i0++];\n//             groupIncrement();\n//           }\n  \n//           // If we added any new groups before any old groups,\n//           // update the group index of all the old records.\n//           if (k > i0) for (i0 = 0; i0 < n0; ++i0) {\n//             groupIndex[i0] = reIndex[groupIndex[i0]];\n//           }\n  \n//           // Modify the update and reset behavior based on the cardinality.\n//           // If the cardinality is less than or equal to one, then the groupIndex\n//           // is not needed. If the cardinality is zero, then there are no records\n//           // and therefore no groups to update or reset. Note that we also must\n//           // change the registered listener to point to the new method.\n//           j = filterListeners.indexOf(update);\n//           if (k > 1) {\n//             update = updateMany;\n//             reset = resetMany;\n//           } else {\n//             if (!k && groupAll) {\n//               k = 1;\n//               groups = [{key: null, value: initial()}];\n//             }\n//             if (k === 1) {\n//               update = updateOne;\n//               reset = resetOne;\n//             } else {\n//               update = crossfilter_null;\n//               reset = crossfilter_null;\n//             }\n//             groupIndex = null;\n//           }\n//           filterListeners[j] = update;\n  \n//           // Count the number of added groups,\n//           // and widen the group index as needed.\n//           function groupIncrement() {\n//             if (++k === groupCapacity) {\n//               reIndex = crossfilter_arrayWiden(reIndex, groupWidth <<= 1);\n//               groupIndex = crossfilter_arrayWiden(groupIndex, groupWidth);\n//               groupCapacity = crossfilter_capacity(groupWidth);\n//             }\n//           }\n//         }\n  \n//         function removeData() {\n//           if (k > 1) {\n//             var oldK = k,\n//                 oldGroups = groups,\n//                 seenGroups = crossfilter_index(oldK, oldK);\n  \n//             // Filter out non-matches by copying matching group index entries to\n//             // the beginning of the array.\n//             for (var i = 0, j = 0; i < n; ++i) {\n//               if (filters[i]) {\n//                 seenGroups[groupIndex[j] = groupIndex[i]] = 1;\n//                 ++j;\n//               }\n//             }\n  \n//             // Reassemble groups including only those groups that were referred\n//             // to by matching group index entries.  Note the new group index in\n//             // seenGroups.\n//             groups = [], k = 0;\n//             for (i = 0; i < oldK; ++i) {\n//               if (seenGroups[i]) {\n//                 seenGroups[i] = k++;\n//                 groups.push(oldGroups[i]);\n//               }\n//             }\n  \n//             if (k > 1) {\n//               // Reindex the group index using seenGroups to find the new index.\n//               for (var i = 0; i < j; ++i) groupIndex[i] = seenGroups[groupIndex[i]];\n//             } else {\n//               groupIndex = null;\n//             }\n//             filterListeners[filterListeners.indexOf(update)] = k > 1\n//                 ? (reset = resetMany, update = updateMany)\n//                 : k === 1 ? (reset = resetOne, update = updateOne)\n//                 : reset = update = crossfilter_null;\n//           } else if (k === 1) {\n//             if (groupAll) return;\n//             for (var i = 0; i < n; ++i) if (filters[i]) return;\n//             groups = [], k = 0;\n//             filterListeners[filterListeners.indexOf(update)] =\n//             update = reset = crossfilter_null;\n//           }\n//         }\n  \n//         // Reduces the specified selected or deselected records.\n//         // This function is only used when the cardinality is greater than 1.\n//         function updateMany(filterOne, added, removed) {\n//           if (filterOne === one || resetNeeded) return;\n  \n//           var i,\n//               k,\n//               n,\n//               g;\n  \n//           // Add the added values.\n//           for (i = 0, n = added.length; i < n; ++i) {\n//             if (!(filters[k = added[i]] & zero)) {\n//               g = groups[groupIndex[k]];\n//               g.value = reduceAdd(g.value, data[k]);\n//             }\n//           }\n  \n//           // Remove the removed values.\n//           for (i = 0, n = removed.length; i < n; ++i) {\n//             if ((filters[k = removed[i]] & zero) === filterOne) {\n//               g = groups[groupIndex[k]];\n//               g.value = reduceRemove(g.value, data[k]);\n//             }\n//           }\n//         }\n  \n//         // Reduces the specified selected or deselected records.\n//         // This function is only used when the cardinality is 1.\n//         function updateOne(filterOne, added, removed) {\n//           if (filterOne === one || resetNeeded) return;\n  \n//           var i,\n//               k,\n//               n,\n//               g = groups[0];\n  \n//           // Add the added values.\n//           for (i = 0, n = added.length; i < n; ++i) {\n//             if (!(filters[k = added[i]] & zero)) {\n//               g.value = reduceAdd(g.value, data[k]);\n//             }\n//           }\n  \n//           // Remove the removed values.\n//           for (i = 0, n = removed.length; i < n; ++i) {\n//             if ((filters[k = removed[i]] & zero) === filterOne) {\n//               g.value = reduceRemove(g.value, data[k]);\n//             }\n//           }\n//         }\n  \n//         // Recomputes the group reduce values from scratch.\n//         // This function is only used when the cardinality is greater than 1.\n//         function resetMany() {\n//           var i,\n//               g;\n  \n//           // Reset all group values.\n//           for (i = 0; i < k; ++i) {\n//             groups[i].value = reduceInitial();\n//           }\n  \n//           // Add any selected records.\n//           for (i = 0; i < n; ++i) {\n//             if (!(filters[i] & zero)) {\n//               g = groups[groupIndex[i]];\n//               g.value = reduceAdd(g.value, data[i]);\n//             }\n//           }\n//         }\n  \n//         // Recomputes the group reduce values from scratch.\n//         // This function is only used when the cardinality is 1.\n//         function resetOne() {\n//           var i,\n//               g = groups[0];\n  \n//           // Reset the singleton group values.\n//           g.value = reduceInitial();\n  \n//           // Add any selected records.\n//           for (i = 0; i < n; ++i) {\n//             if (!(filters[i] & zero)) {\n//               g.value = reduceAdd(g.value, data[i]);\n//             }\n//           }\n//         }\n  \n//         // Returns the array of group values, in the dimension's natural order.\n//         function all() {\n//           if (resetNeeded) reset(), resetNeeded = false;\n//           return groups;\n//         }\n  \n//         // Returns a new array containing the top K group values, in reduce order.\n//         function top(k) {\n//           var top = select(all(), 0, groups.length, k);\n//           return heap.sort(top, 0, top.length);\n//         }\n  \n//         // Sets the reduce behavior for this group to use the specified functions.\n//         // This method lazily recomputes the reduce values, waiting until needed.\n//         function reduce(add, remove, initial) {\n//           reduceAdd = add;\n//           reduceRemove = remove;\n//           reduceInitial = initial;\n//           resetNeeded = true;\n//           return group;\n//         }\n  \n//         // A convenience method for reducing by count.\n//         function reduceCount() {\n//           return reduce(crossfilter_reduceIncrement, crossfilter_reduceDecrement, crossfilter_zero);\n//         }\n  \n//         // A convenience method for reducing by sum(value).\n//         function reduceSum(value) {\n//           return reduce(crossfilter_reduceAdd(value), crossfilter_reduceSubtract(value), crossfilter_zero);\n//         }\n  \n//         // Sets the reduce order, using the specified accessor.\n//         function order(value) {\n//           select = heapselect_by(valueOf);\n//           heap = heap_by(valueOf);\n//           function valueOf(d) { return value(d.value); }\n//           return group;\n//         }\n  \n//         // A convenience method for natural ordering by reduce value.\n//         function orderNatural() {\n//           return order(crossfilter_identity);\n//         }\n  \n//         // Returns the cardinality of this group, irrespective of any filters.\n//         function size() {\n//           return k;\n//         }\n  \n//         // Removes this group and associated event listeners.\n//         function dispose() {\n//           var i = filterListeners.indexOf(update);\n//           if (i >= 0) filterListeners.splice(i, 1);\n//           i = indexListeners.indexOf(add);\n//           if (i >= 0) indexListeners.splice(i, 1);\n//           i = removeDataListeners.indexOf(removeData);\n//           if (i >= 0) removeDataListeners.splice(i, 1);\n//           return group;\n//         }\n  \n//         return reduceCount().orderNatural();\n//       }\n  \n//       // A convenience function for generating a singleton group.\n//       function groupAll() {\n//         var g = group(crossfilter_null), all = g.all;\n//         delete g.all;\n//         delete g.top;\n//         delete g.order;\n//         delete g.orderNatural;\n//         delete g.size;\n//         g.value = function() { return all()[0].value; };\n//         return g;\n//       }\n  \n//       // Removes this dimension and associated groups and event listeners.\n//       function dispose() {\n//         dimensionGroups.forEach(function(group) { group.dispose(); });\n//         var i = dataListeners.indexOf(preAdd);\n//         if (i >= 0) dataListeners.splice(i, 1);\n//         i = dataListeners.indexOf(postAdd);\n//         if (i >= 0) dataListeners.splice(i, 1);\n//         i = removeDataListeners.indexOf(removeData);\n//         if (i >= 0) removeDataListeners.splice(i, 1);\n//         m &= zero;\n//         return filterAll();\n//       }\n  \n//       return dimension;\n//     }\n  \n//     // A convenience method for groupAll on a dummy dimension.\n//     // This implementation can be optimized since it always has cardinality 1.\n//     function groupAll() {\n//       var group = {\n//         reduce: reduce,\n//         reduceCount: reduceCount,\n//         reduceSum: reduceSum,\n//         value: value,\n//         dispose: dispose,\n//         remove: dispose // for backwards-compatibility\n//       };\n  \n//       var reduceValue,\n//           reduceAdd,\n//           reduceRemove,\n//           reduceInitial,\n//           resetNeeded = true;\n  \n//       // The group listens to the crossfilter for when any dimension changes, so\n//       // that it can update the reduce value. It must also listen to the parent\n//       // dimension for when data is added.\n//       filterListeners.push(update);\n//       dataListeners.push(add);\n  \n//       // For consistency; actually a no-op since resetNeeded is true.\n//       add(data, 0, n);\n  \n//       // Incorporates the specified new values into this group.\n//       function add(newData, n0) {\n//         var i;\n  \n//         if (resetNeeded) return;\n  \n//         // Add the added values.\n//         for (i = n0; i < n; ++i) {\n//           if (!filters[i]) {\n//             reduceValue = reduceAdd(reduceValue, data[i]);\n//           }\n//         }\n//       }\n  \n//       // Reduces the specified selected or deselected records.\n//       function update(filterOne, added, removed) {\n//         var i,\n//             k,\n//             n;\n  \n//         if (resetNeeded) return;\n  \n//         // Add the added values.\n//         for (i = 0, n = added.length; i < n; ++i) {\n//           if (!filters[k = added[i]]) {\n//             reduceValue = reduceAdd(reduceValue, data[k]);\n//           }\n//         }\n  \n//         // Remove the removed values.\n//         for (i = 0, n = removed.length; i < n; ++i) {\n//           if (filters[k = removed[i]] === filterOne) {\n//             reduceValue = reduceRemove(reduceValue, data[k]);\n//           }\n//         }\n//       }\n  \n//       // Recomputes the group reduce value from scratch.\n//       function reset() {\n//         var i;\n  \n//         reduceValue = reduceInitial();\n  \n//         for (i = 0; i < n; ++i) {\n//           if (!filters[i]) {\n//             reduceValue = reduceAdd(reduceValue, data[i]);\n//           }\n//         }\n//       }\n  \n//       // Sets the reduce behavior for this group to use the specified functions.\n//       // This method lazily recomputes the reduce value, waiting until needed.\n//       function reduce(add, remove, initial) {\n//         reduceAdd = add;\n//         reduceRemove = remove;\n//         reduceInitial = initial;\n//         resetNeeded = true;\n//         return group;\n//       }\n  \n//       // A convenience method for reducing by count.\n//       function reduceCount() {\n//         return reduce(crossfilter_reduceIncrement, crossfilter_reduceDecrement, crossfilter_zero);\n//       }\n  \n//       // A convenience method for reducing by sum(value).\n//       function reduceSum(value) {\n//         return reduce(crossfilter_reduceAdd(value), crossfilter_reduceSubtract(value), crossfilter_zero);\n//       }\n  \n//       // Returns the computed reduce value.\n//       function value() {\n//         if (resetNeeded) reset(), resetNeeded = false;\n//         return reduceValue;\n//       }\n  \n//       // Removes this group and associated event listeners.\n//       function dispose() {\n//         var i = filterListeners.indexOf(update);\n//         if (i >= 0) filterListeners.splice(i);\n//         i = dataListeners.indexOf(add);\n//         if (i >= 0) dataListeners.splice(i);\n//         return group;\n//       }\n  \n//       return reduceCount();\n//     }\n  \n//     // Returns the number of records in this crossfilter, irrespective of any filters.\n//     function size() {\n//       return n;\n//     }\n  \n//     return arguments.length\n//         ? add(arguments[0])\n//         : crossfilter;\n//   }\n  \n//   // Returns an array of size n, big enough to store ids up to m.\n//   function crossfilter_index(n, m) {\n//     return (m < 0x101\n//         ? crossfilter_array8 : m < 0x10001\n//         ? crossfilter_array16\n//         : crossfilter_array32)(n);\n//   }\n  \n//   // Constructs a new array of size n, with sequential values from 0 to n - 1.\n//   function crossfilter_range(n) {\n//     var range = crossfilter_index(n, n);\n//     for (var i = -1; ++i < n;) range[i] = i;\n//     return range;\n//   }\n  \n//   function crossfilter_capacity(w) {\n//     return w === 8\n//         ? 0x100 : w === 16\n//         ? 0x10000\n//         : 0x100000000;\n//   }\n//   })(typeof exports !== 'undefined' && exports || this);"]}
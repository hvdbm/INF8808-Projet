{"version":3,"sources":["scripts/crossfilter.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA","file":"crossfilter.0fb212d0.js","sourceRoot":"..","sourcesContent":["// (function(exports){\r\n//   crossfilter.version = \"1.3.14\";\r\n//   function crossfilter_identity(d) {\r\n//     return d;\r\n//   }\r\n//   crossfilter.permute = permute;\r\n  \r\n//   function permute(array, index) {\r\n//     for (var i = 0, n = index.length, copy = new Array(n); i < n; ++i) {\r\n//       copy[i] = array[index[i]];\r\n//     }\r\n//     return copy;\r\n//   }\r\n//   var bisect = crossfilter.bisect = bisect_by(crossfilter_identity);\r\n  \r\n//   bisect.by = bisect_by;\r\n  \r\n//   function bisect_by(f) {\r\n  \r\n//     // Locate the insertion point for x in a to maintain sorted order. The\r\n//     // arguments lo and hi may be used to specify a subset of the array which\r\n//     // should be considered; by default the entire array is used. If x is already\r\n//     // present in a, the insertion point will be before (to the left of) any\r\n//     // existing entries. The return value is suitable for use as the first\r\n//     // argument to `array.splice` assuming that a is already sorted.\r\n//     //\r\n//     // The returned insertion point i partitions the array a into two halves so\r\n//     // that all v < x for v in a[lo:i] for the left side and all v >= x for v in\r\n//     // a[i:hi] for the right side.\r\n//     function bisectLeft(a, x, lo, hi) {\r\n//       while (lo < hi) {\r\n//         var mid = lo + hi >>> 1;\r\n//         if (f(a[mid]) < x) lo = mid + 1;\r\n//         else hi = mid;\r\n//       }\r\n//       return lo;\r\n//     }\r\n  \r\n//     // Similar to bisectLeft, but returns an insertion point which comes after (to\r\n//     // the right of) any existing entries of x in a.\r\n//     //\r\n//     // The returned insertion point i partitions the array into two halves so that\r\n//     // all v <= x for v in a[lo:i] for the left side and all v > x for v in\r\n//     // a[i:hi] for the right side.\r\n//     function bisectRight(a, x, lo, hi) {\r\n//       while (lo < hi) {\r\n//         var mid = lo + hi >>> 1;\r\n//         if (x < f(a[mid])) hi = mid;\r\n//         else lo = mid + 1;\r\n//       }\r\n//       return lo;\r\n//     }\r\n  \r\n//     bisectRight.right = bisectRight;\r\n//     bisectRight.left = bisectLeft;\r\n//     return bisectRight;\r\n//   }\r\n//   var heap = crossfilter.heap = heap_by(crossfilter_identity);\r\n  \r\n//   heap.by = heap_by;\r\n  \r\n//   function heap_by(f) {\r\n  \r\n//     // Builds a binary heap within the specified array a[lo:hi]. The heap has the\r\n//     // property such that the parent a[lo+i] is always less than or equal to its\r\n//     // two children: a[lo+2*i+1] and a[lo+2*i+2].\r\n//     function heap(a, lo, hi) {\r\n//       var n = hi - lo,\r\n//           i = (n >>> 1) + 1;\r\n//       while (--i > 0) sift(a, i, n, lo);\r\n//       return a;\r\n//     }\r\n  \r\n//     // Sorts the specified array a[lo:hi] in descending order, assuming it is\r\n//     // already a heap.\r\n//     function sort(a, lo, hi) {\r\n//       var n = hi - lo,\r\n//           t;\r\n//       while (--n > 0) t = a[lo], a[lo] = a[lo + n], a[lo + n] = t, sift(a, 1, n, lo);\r\n//       return a;\r\n//     }\r\n  \r\n//     // Sifts the element a[lo+i-1] down the heap, where the heap is the contiguous\r\n//     // slice of array a[lo:lo+n]. This method can also be used to update the heap\r\n//     // incrementally, without incurring the full cost of reconstructing the heap.\r\n//     function sift(a, i, n, lo) {\r\n//       var d = a[--lo + i],\r\n//           x = f(d),\r\n//           child;\r\n//       while ((child = i << 1) <= n) {\r\n//         if (child < n && f(a[lo + child]) > f(a[lo + child + 1])) child++;\r\n//         if (x <= f(a[lo + child])) break;\r\n//         a[lo + i] = a[lo + child];\r\n//         i = child;\r\n//       }\r\n//       a[lo + i] = d;\r\n//     }\r\n  \r\n//     heap.sort = sort;\r\n//     return heap;\r\n//   }\r\n//   var heapselect = crossfilter.heapselect = heapselect_by(crossfilter_identity);\r\n  \r\n//   heapselect.by = heapselect_by;\r\n  \r\n//   function heapselect_by(f) {\r\n//     var heap = heap_by(f);\r\n  \r\n//     // Returns a new array containing the top k elements in the array a[lo:hi].\r\n//     // The returned array is not sorted, but maintains the heap property. If k is\r\n//     // greater than hi - lo, then fewer than k elements will be returned. The\r\n//     // order of elements in a is unchanged by this operation.\r\n//     function heapselect(a, lo, hi, k) {\r\n//       var queue = new Array(k = Math.min(hi - lo, k)),\r\n//           min,\r\n//           i,\r\n//           x,\r\n//           d;\r\n  \r\n//       for (i = 0; i < k; ++i) queue[i] = a[lo++];\r\n//       heap(queue, 0, k);\r\n  \r\n//       if (lo < hi) {\r\n//         min = f(queue[0]);\r\n//         do {\r\n//           if (x = f(d = a[lo]) > min) {\r\n//             queue[0] = d;\r\n//             min = f(heap(queue, 0, k)[0]);\r\n//           }\r\n//         } while (++lo < hi);\r\n//       }\r\n  \r\n//       return queue;\r\n//     }\r\n  \r\n//     return heapselect;\r\n//   }\r\n//   var insertionsort = crossfilter.insertionsort = insertionsort_by(crossfilter_identity);\r\n  \r\n//   insertionsort.by = insertionsort_by;\r\n  \r\n//   function insertionsort_by(f) {\r\n  \r\n//     function insertionsort(a, lo, hi) {\r\n//       for (var i = lo + 1; i < hi; ++i) {\r\n//         for (var j = i, t = a[i], x = f(t); j > lo && f(a[j - 1]) > x; --j) {\r\n//           a[j] = a[j - 1];\r\n//         }\r\n//         a[j] = t;\r\n//       }\r\n//       return a;\r\n//     }\r\n  \r\n//     return insertionsort;\r\n//   }\r\n//   // Algorithm designed by Vladimir Yaroslavskiy.\r\n//   // Implementation based on the Dart project; see lib/dart/LICENSE for details.\r\n  \r\n//   var quicksort = crossfilter.quicksort = quicksort_by(crossfilter_identity);\r\n  \r\n//   quicksort.by = quicksort_by;\r\n  \r\n//   function quicksort_by(f) {\r\n//     var insertionsort = insertionsort_by(f);\r\n  \r\n//     function sort(a, lo, hi) {\r\n//       return (hi - lo < quicksort_sizeThreshold\r\n//           ? insertionsort\r\n//           : quicksort)(a, lo, hi);\r\n//     }\r\n  \r\n//     function quicksort(a, lo, hi) {\r\n//       // Compute the two pivots by looking at 5 elements.\r\n//       var sixth = (hi - lo) / 6 | 0,\r\n//           i1 = lo + sixth,\r\n//           i5 = hi - 1 - sixth,\r\n//           i3 = lo + hi - 1 >> 1,  // The midpoint.\r\n//           i2 = i3 - sixth,\r\n//           i4 = i3 + sixth;\r\n  \r\n//       var e1 = a[i1], x1 = f(e1),\r\n//           e2 = a[i2], x2 = f(e2),\r\n//           e3 = a[i3], x3 = f(e3),\r\n//           e4 = a[i4], x4 = f(e4),\r\n//           e5 = a[i5], x5 = f(e5);\r\n  \r\n//       var t;\r\n  \r\n//       // Sort the selected 5 elements using a sorting network.\r\n//       if (x1 > x2) t = e1, e1 = e2, e2 = t, t = x1, x1 = x2, x2 = t;\r\n//       if (x4 > x5) t = e4, e4 = e5, e5 = t, t = x4, x4 = x5, x5 = t;\r\n//       if (x1 > x3) t = e1, e1 = e3, e3 = t, t = x1, x1 = x3, x3 = t;\r\n//       if (x2 > x3) t = e2, e2 = e3, e3 = t, t = x2, x2 = x3, x3 = t;\r\n//       if (x1 > x4) t = e1, e1 = e4, e4 = t, t = x1, x1 = x4, x4 = t;\r\n//       if (x3 > x4) t = e3, e3 = e4, e4 = t, t = x3, x3 = x4, x4 = t;\r\n//       if (x2 > x5) t = e2, e2 = e5, e5 = t, t = x2, x2 = x5, x5 = t;\r\n//       if (x2 > x3) t = e2, e2 = e3, e3 = t, t = x2, x2 = x3, x3 = t;\r\n//       if (x4 > x5) t = e4, e4 = e5, e5 = t, t = x4, x4 = x5, x5 = t;\r\n  \r\n//       var pivot1 = e2, pivotValue1 = x2,\r\n//           pivot2 = e4, pivotValue2 = x4;\r\n  \r\n//       // e2 and e4 have been saved in the pivot variables. They will be written\r\n//       // back, once the partitioning is finished.\r\n//       a[i1] = e1;\r\n//       a[i2] = a[lo];\r\n//       a[i3] = e3;\r\n//       a[i4] = a[hi - 1];\r\n//       a[i5] = e5;\r\n  \r\n//       var less = lo + 1,   // First element in the middle partition.\r\n//           great = hi - 2;  // Last element in the middle partition.\r\n  \r\n//       // Note that for value comparison, <, <=, >= and > coerce to a primitive via\r\n//       // Object.prototype.valueOf; == and === do not, so in order to be consistent\r\n//       // with natural order (such as for Date objects), we must do two compares.\r\n//       var pivotsEqual = pivotValue1 <= pivotValue2 && pivotValue1 >= pivotValue2;\r\n//       if (pivotsEqual) {\r\n  \r\n//         // Degenerated case where the partitioning becomes a dutch national flag\r\n//         // problem.\r\n//         //\r\n//         // [ |  < pivot  | == pivot | unpartitioned | > pivot  | ]\r\n//         //  ^             ^          ^             ^            ^\r\n//         // left         less         k           great         right\r\n//         //\r\n//         // a[left] and a[right] are undefined and are filled after the\r\n//         // partitioning.\r\n//         //\r\n//         // Invariants:\r\n//         //   1) for x in ]left, less[ : x < pivot.\r\n//         //   2) for x in [less, k[ : x == pivot.\r\n//         //   3) for x in ]great, right[ : x > pivot.\r\n//         for (var k = less; k <= great; ++k) {\r\n//           var ek = a[k], xk = f(ek);\r\n//           if (xk < pivotValue1) {\r\n//             if (k !== less) {\r\n//               a[k] = a[less];\r\n//               a[less] = ek;\r\n//             }\r\n//             ++less;\r\n//           } else if (xk > pivotValue1) {\r\n  \r\n//             // Find the first element <= pivot in the range [k - 1, great] and\r\n//             // put [:ek:] there. We know that such an element must exist:\r\n//             // When k == less, then el3 (which is equal to pivot) lies in the\r\n//             // interval. Otherwise a[k - 1] == pivot and the search stops at k-1.\r\n//             // Note that in the latter case invariant 2 will be violated for a\r\n//             // short amount of time. The invariant will be restored when the\r\n//             // pivots are put into their final positions.\r\n//             while (true) {\r\n//               var greatValue = f(a[great]);\r\n//               if (greatValue > pivotValue1) {\r\n//                 great--;\r\n//                 // This is the only location in the while-loop where a new\r\n//                 // iteration is started.\r\n//                 continue;\r\n//               } else if (greatValue < pivotValue1) {\r\n//                 // Triple exchange.\r\n//                 a[k] = a[less];\r\n//                 a[less++] = a[great];\r\n//                 a[great--] = ek;\r\n//                 break;\r\n//               } else {\r\n//                 a[k] = a[great];\r\n//                 a[great--] = ek;\r\n//                 // Note: if great < k then we will exit the outer loop and fix\r\n//                 // invariant 2 (which we just violated).\r\n//                 break;\r\n//               }\r\n//             }\r\n//           }\r\n//         }\r\n//       } else {\r\n  \r\n//         // We partition the list into three parts:\r\n//         //  1. < pivot1\r\n//         //  2. >= pivot1 && <= pivot2\r\n//         //  3. > pivot2\r\n//         //\r\n//         // During the loop we have:\r\n//         // [ | < pivot1 | >= pivot1 && <= pivot2 | unpartitioned  | > pivot2  | ]\r\n//         //  ^            ^                        ^              ^             ^\r\n//         // left         less                     k              great        right\r\n//         //\r\n//         // a[left] and a[right] are undefined and are filled after the\r\n//         // partitioning.\r\n//         //\r\n//         // Invariants:\r\n//         //   1. for x in ]left, less[ : x < pivot1\r\n//         //   2. for x in [less, k[ : pivot1 <= x && x <= pivot2\r\n//         //   3. for x in ]great, right[ : x > pivot2\r\n//         for (var k = less; k <= great; k++) {\r\n//           var ek = a[k], xk = f(ek);\r\n//           if (xk < pivotValue1) {\r\n//             if (k !== less) {\r\n//               a[k] = a[less];\r\n//               a[less] = ek;\r\n//             }\r\n//             ++less;\r\n//           } else {\r\n//             if (xk > pivotValue2) {\r\n//               while (true) {\r\n//                 var greatValue = f(a[great]);\r\n//                 if (greatValue > pivotValue2) {\r\n//                   great--;\r\n//                   if (great < k) break;\r\n//                   // This is the only location inside the loop where a new\r\n//                   // iteration is started.\r\n//                   continue;\r\n//                 } else {\r\n//                   // a[great] <= pivot2.\r\n//                   if (greatValue < pivotValue1) {\r\n//                     // Triple exchange.\r\n//                     a[k] = a[less];\r\n//                     a[less++] = a[great];\r\n//                     a[great--] = ek;\r\n//                   } else {\r\n//                     // a[great] >= pivot1.\r\n//                     a[k] = a[great];\r\n//                     a[great--] = ek;\r\n//                   }\r\n//                   break;\r\n//                 }\r\n//               }\r\n//             }\r\n//           }\r\n//         }\r\n//       }\r\n  \r\n//       // Move pivots into their final positions.\r\n//       // We shrunk the list from both sides (a[left] and a[right] have\r\n//       // meaningless values in them) and now we move elements from the first\r\n//       // and third partition into these locations so that we can store the\r\n//       // pivots.\r\n//       a[lo] = a[less - 1];\r\n//       a[less - 1] = pivot1;\r\n//       a[hi - 1] = a[great + 1];\r\n//       a[great + 1] = pivot2;\r\n  \r\n//       // The list is now partitioned into three partitions:\r\n//       // [ < pivot1   | >= pivot1 && <= pivot2   |  > pivot2   ]\r\n//       //  ^            ^                        ^             ^\r\n//       // left         less                     great        right\r\n  \r\n//       // Recursive descent. (Don't include the pivot values.)\r\n//       sort(a, lo, less - 1);\r\n//       sort(a, great + 2, hi);\r\n  \r\n//       if (pivotsEqual) {\r\n//         // All elements in the second partition are equal to the pivot. No\r\n//         // need to sort them.\r\n//         return a;\r\n//       }\r\n  \r\n//       // In theory it should be enough to call _doSort recursively on the second\r\n//       // partition.\r\n//       // The Android source however removes the pivot elements from the recursive\r\n//       // call if the second partition is too large (more than 2/3 of the list).\r\n//       if (less < i1 && great > i5) {\r\n//         var lessValue, greatValue;\r\n//         while ((lessValue = f(a[less])) <= pivotValue1 && lessValue >= pivotValue1) ++less;\r\n//         while ((greatValue = f(a[great])) <= pivotValue2 && greatValue >= pivotValue2) --great;\r\n  \r\n//         // Copy paste of the previous 3-way partitioning with adaptions.\r\n//         //\r\n//         // We partition the list into three parts:\r\n//         //  1. == pivot1\r\n//         //  2. > pivot1 && < pivot2\r\n//         //  3. == pivot2\r\n//         //\r\n//         // During the loop we have:\r\n//         // [ == pivot1 | > pivot1 && < pivot2 | unpartitioned  | == pivot2 ]\r\n//         //              ^                      ^              ^\r\n//         //            less                     k              great\r\n//         //\r\n//         // Invariants:\r\n//         //   1. for x in [ *, less[ : x == pivot1\r\n//         //   2. for x in [less, k[ : pivot1 < x && x < pivot2\r\n//         //   3. for x in ]great, * ] : x == pivot2\r\n//         for (var k = less; k <= great; k++) {\r\n//           var ek = a[k], xk = f(ek);\r\n//           if (xk <= pivotValue1 && xk >= pivotValue1) {\r\n//             if (k !== less) {\r\n//               a[k] = a[less];\r\n//               a[less] = ek;\r\n//             }\r\n//             less++;\r\n//           } else {\r\n//             if (xk <= pivotValue2 && xk >= pivotValue2) {\r\n//               while (true) {\r\n//                 var greatValue = f(a[great]);\r\n//                 if (greatValue <= pivotValue2 && greatValue >= pivotValue2) {\r\n//                   great--;\r\n//                   if (great < k) break;\r\n//                   // This is the only location inside the loop where a new\r\n//                   // iteration is started.\r\n//                   continue;\r\n//                 } else {\r\n//                   // a[great] < pivot2.\r\n//                   if (greatValue < pivotValue1) {\r\n//                     // Triple exchange.\r\n//                     a[k] = a[less];\r\n//                     a[less++] = a[great];\r\n//                     a[great--] = ek;\r\n//                   } else {\r\n//                     // a[great] == pivot1.\r\n//                     a[k] = a[great];\r\n//                     a[great--] = ek;\r\n//                   }\r\n//                   break;\r\n//                 }\r\n//               }\r\n//             }\r\n//           }\r\n//         }\r\n//       }\r\n  \r\n//       // The second partition has now been cleared of pivot elements and looks\r\n//       // as follows:\r\n//       // [  *  |  > pivot1 && < pivot2  | * ]\r\n//       //        ^                      ^\r\n//       //       less                  great\r\n//       // Sort the second partition using recursive descent.\r\n  \r\n//       // The second partition looks as follows:\r\n//       // [  *  |  >= pivot1 && <= pivot2  | * ]\r\n//       //        ^                        ^\r\n//       //       less                    great\r\n//       // Simply sort it by recursive descent.\r\n  \r\n//       return sort(a, less, great + 1);\r\n//     }\r\n  \r\n//     return sort;\r\n//   }\r\n  \r\n//   var quicksort_sizeThreshold = 32;\r\n//   var crossfilter_array8 = crossfilter_arrayUntyped,\r\n//       crossfilter_array16 = crossfilter_arrayUntyped,\r\n//       crossfilter_array32 = crossfilter_arrayUntyped,\r\n//       crossfilter_arrayLengthen = crossfilter_arrayLengthenUntyped,\r\n//       crossfilter_arrayWiden = crossfilter_arrayWidenUntyped;\r\n  \r\n//   if (typeof Uint8Array !== \"undefined\") {\r\n//     crossfilter_array8 = function(n) { return new Uint8Array(n); };\r\n//     crossfilter_array16 = function(n) { return new Uint16Array(n); };\r\n//     crossfilter_array32 = function(n) { return new Uint32Array(n); };\r\n  \r\n//     crossfilter_arrayLengthen = function(array, length) {\r\n//       if (array.length >= length) return array;\r\n//       var copy = new array.constructor(length);\r\n//       copy.set(array);\r\n//       return copy;\r\n//     };\r\n  \r\n//     crossfilter_arrayWiden = function(array, width) {\r\n//       var copy;\r\n//       switch (width) {\r\n//         case 16: copy = crossfilter_array16(array.length); break;\r\n//         case 32: copy = crossfilter_array32(array.length); break;\r\n//         default: throw new Error(\"invalid array width!\");\r\n//       }\r\n//       copy.set(array);\r\n//       return copy;\r\n//     };\r\n//   }\r\n  \r\n//   function crossfilter_arrayUntyped(n) {\r\n//     var array = new Array(n), i = -1;\r\n//     while (++i < n) array[i] = 0;\r\n//     return array;\r\n//   }\r\n  \r\n//   function crossfilter_arrayLengthenUntyped(array, length) {\r\n//     var n = array.length;\r\n//     while (n < length) array[n++] = 0;\r\n//     return array;\r\n//   }\r\n  \r\n//   function crossfilter_arrayWidenUntyped(array, width) {\r\n//     if (width > 32) throw new Error(\"invalid array width!\");\r\n//     return array;\r\n//   }\r\n//   function crossfilter_filterExact(bisect, value) {\r\n//     return function(values) {\r\n//       var n = values.length;\r\n//       return [bisect.left(values, value, 0, n), bisect.right(values, value, 0, n)];\r\n//     };\r\n//   }\r\n  \r\n//   function crossfilter_filterRange(bisect, range) {\r\n//     var min = range[0],\r\n//         max = range[1];\r\n//     return function(values) {\r\n//       var n = values.length;\r\n//       return [bisect.left(values, min, 0, n), bisect.left(values, max, 0, n)];\r\n//     };\r\n//   }\r\n  \r\n//   function crossfilter_filterAll(values) {\r\n//     return [0, values.length];\r\n//   }\r\n//   function crossfilter_null() {\r\n//     return null;\r\n//   }\r\n//   function crossfilter_zero() {\r\n//     return 0;\r\n//   }\r\n//   function crossfilter_reduceIncrement(p) {\r\n//     return p + 1;\r\n//   }\r\n  \r\n//   function crossfilter_reduceDecrement(p) {\r\n//     return p - 1;\r\n//   }\r\n  \r\n//   function crossfilter_reduceAdd(f) {\r\n//     return function(p, v) {\r\n//       return p + +f(v);\r\n//     };\r\n//   }\r\n  \r\n//   function crossfilter_reduceSubtract(f) {\r\n//     return function(p, v) {\r\n//       return p - f(v);\r\n//     };\r\n//   }\r\n//   exports.crossfilter = crossfilter;\r\n  \r\n//   function crossfilter() {\r\n//     var crossfilter = {\r\n//       add: add,\r\n//       remove: removeData,\r\n//       dimension: dimension,\r\n//       groupAll: groupAll,\r\n//       size: size\r\n//     };\r\n  \r\n//     var data = [], // the records\r\n//         n = 0, // the number of records; data.length\r\n//         m = 0, // a bit mask representing which dimensions are in use\r\n//         M = 8, // number of dimensions that can fit in `filters`\r\n//         filters = crossfilter_array8(0), // M bits per record; 1 is filtered out\r\n//         filterListeners = [], // when the filters change\r\n//         dataListeners = [], // when data is added\r\n//         removeDataListeners = []; // when data is removed\r\n  \r\n//     // Adds the specified new records to this crossfilter.\r\n//     function add(newData) {\r\n//       var n0 = n,\r\n//           n1 = newData.length;\r\n  \r\n//       // If there's actually new data to add…\r\n//       // Merge the new data into the existing data.\r\n//       // Lengthen the filter bitset to handle the new records.\r\n//       // Notify listeners (dimensions and groups) that new data is available.\r\n//       if (n1) {\r\n//         data = data.concat(newData);\r\n//         filters = crossfilter_arrayLengthen(filters, n += n1);\r\n//         dataListeners.forEach(function(l) { l(newData, n0, n1); });\r\n//       }\r\n  \r\n//       return crossfilter;\r\n//     }\r\n  \r\n//     // Removes all records that match the current filters.\r\n//     function removeData() {\r\n//       var newIndex = crossfilter_index(n, n),\r\n//           removed = [];\r\n//       for (var i = 0, j = 0; i < n; ++i) {\r\n//         if (filters[i]) newIndex[i] = j++;\r\n//         else removed.push(i);\r\n//       }\r\n  \r\n//       // Remove all matching records from groups.\r\n//       filterListeners.forEach(function(l) { l(0, [], removed); });\r\n  \r\n//       // Update indexes.\r\n//       removeDataListeners.forEach(function(l) { l(newIndex); });\r\n  \r\n//       // Remove old filters and data by overwriting.\r\n//       for (var i = 0, j = 0, k; i < n; ++i) {\r\n//         if (k = filters[i]) {\r\n//           if (i !== j) filters[j] = k, data[j] = data[i];\r\n//           ++j;\r\n//         }\r\n//       }\r\n//       data.length = j;\r\n//       while (n > j) filters[--n] = 0;\r\n//     }\r\n  \r\n//     // Adds a new dimension with the specified value accessor function.\r\n//     function dimension(value) {\r\n//       var dimension = {\r\n//         filter: filter,\r\n//         filterExact: filterExact,\r\n//         filterRange: filterRange,\r\n//         filterFunction: filterFunction,\r\n//         filterAll: filterAll,\r\n//         top: top,\r\n//         bottom: bottom,\r\n//         group: group,\r\n//         groupAll: groupAll,\r\n//         dispose: dispose,\r\n//         remove: dispose // for backwards-compatibility\r\n//       };\r\n  \r\n//       var one = ~m & -~m, // lowest unset bit as mask, e.g., 00001000\r\n//           zero = ~one, // inverted one, e.g., 11110111\r\n//           values, // sorted, cached array\r\n//           index, // value rank ↦ object id\r\n//           newValues, // temporary array storing newly-added values\r\n//           newIndex, // temporary array storing newly-added index\r\n//           sort = quicksort_by(function(i) { return newValues[i]; }),\r\n//           refilter = crossfilter_filterAll, // for recomputing filter\r\n//           refilterFunction, // the custom filter function in use\r\n//           indexListeners = [], // when data is added\r\n//           dimensionGroups = [],\r\n//           lo0 = 0,\r\n//           hi0 = 0;\r\n  \r\n//       // Updating a dimension is a two-stage process. First, we must update the\r\n//       // associated filters for the newly-added records. Once all dimensions have\r\n//       // updated their filters, the groups are notified to update.\r\n//       dataListeners.unshift(preAdd);\r\n//       dataListeners.push(postAdd);\r\n  \r\n//       removeDataListeners.push(removeData);\r\n  \r\n//       // Incorporate any existing data into this dimension, and make sure that the\r\n//       // filter bitset is wide enough to handle the new dimension.\r\n//       m |= one;\r\n//       if (M >= 32 ? !one : m & -(1 << M)) {\r\n//         filters = crossfilter_arrayWiden(filters, M <<= 1);\r\n//       }\r\n//       preAdd(data, 0, n);\r\n//       postAdd(data, 0, n);\r\n  \r\n//       // Incorporates the specified new records into this dimension.\r\n//       // This function is responsible for updating filters, values, and index.\r\n//       function preAdd(newData, n0, n1) {\r\n  \r\n//         // Permute new values into natural order using a sorted index.\r\n//         newValues = newData.map(value);\r\n//         newIndex = sort(crossfilter_range(n1), 0, n1);\r\n//         newValues = permute(newValues, newIndex);\r\n  \r\n//         // Bisect newValues to determine which new records are selected.\r\n//         var bounds = refilter(newValues), lo1 = bounds[0], hi1 = bounds[1], i;\r\n//         if (refilterFunction) {\r\n//           for (i = 0; i < n1; ++i) {\r\n//             if (!refilterFunction(newValues[i], i)) filters[newIndex[i] + n0] |= one;\r\n//           }\r\n//         } else {\r\n//           for (i = 0; i < lo1; ++i) filters[newIndex[i] + n0] |= one;\r\n//           for (i = hi1; i < n1; ++i) filters[newIndex[i] + n0] |= one;\r\n//         }\r\n  \r\n//         // If this dimension previously had no data, then we don't need to do the\r\n//         // more expensive merge operation; use the new values and index as-is.\r\n//         if (!n0) {\r\n//           values = newValues;\r\n//           index = newIndex;\r\n//           lo0 = lo1;\r\n//           hi0 = hi1;\r\n//           return;\r\n//         }\r\n  \r\n//         var oldValues = values,\r\n//             oldIndex = index,\r\n//             i0 = 0,\r\n//             i1 = 0;\r\n  \r\n//         // Otherwise, create new arrays into which to merge new and old.\r\n//         values = new Array(n);\r\n//         index = crossfilter_index(n, n);\r\n  \r\n//         // Merge the old and new sorted values, and old and new index.\r\n//         for (i = 0; i0 < n0 && i1 < n1; ++i) {\r\n//           if (oldValues[i0] < newValues[i1]) {\r\n//             values[i] = oldValues[i0];\r\n//             index[i] = oldIndex[i0++];\r\n//           } else {\r\n//             values[i] = newValues[i1];\r\n//             index[i] = newIndex[i1++] + n0;\r\n//           }\r\n//         }\r\n  \r\n//         // Add any remaining old values.\r\n//         for (; i0 < n0; ++i0, ++i) {\r\n//           values[i] = oldValues[i0];\r\n//           index[i] = oldIndex[i0];\r\n//         }\r\n  \r\n//         // Add any remaining new values.\r\n//         for (; i1 < n1; ++i1, ++i) {\r\n//           values[i] = newValues[i1];\r\n//           index[i] = newIndex[i1] + n0;\r\n//         }\r\n  \r\n//         // Bisect again to recompute lo0 and hi0.\r\n//         bounds = refilter(values), lo0 = bounds[0], hi0 = bounds[1];\r\n//       }\r\n  \r\n//       // When all filters have updated, notify index listeners of the new values.\r\n//       function postAdd(newData, n0, n1) {\r\n//         indexListeners.forEach(function(l) { l(newValues, newIndex, n0, n1); });\r\n//         newValues = newIndex = null;\r\n//       }\r\n  \r\n//       function removeData(reIndex) {\r\n//         for (var i = 0, j = 0, k; i < n; ++i) {\r\n//           if (filters[k = index[i]]) {\r\n//             if (i !== j) values[j] = values[i];\r\n//             index[j] = reIndex[k];\r\n//             ++j;\r\n//           }\r\n//         }\r\n//         values.length = j;\r\n//         while (j < n) index[j++] = 0;\r\n  \r\n//         // Bisect again to recompute lo0 and hi0.\r\n//         var bounds = refilter(values);\r\n//         lo0 = bounds[0], hi0 = bounds[1];\r\n//       }\r\n  \r\n//       // Updates the selected values based on the specified bounds [lo, hi].\r\n//       // This implementation is used by all the public filter methods.\r\n//       function filterIndexBounds(bounds) {\r\n//         var lo1 = bounds[0],\r\n//             hi1 = bounds[1];\r\n  \r\n//         if (refilterFunction) {\r\n//           refilterFunction = null;\r\n//           filterIndexFunction(function(d, i) { return lo1 <= i && i < hi1; });\r\n//           lo0 = lo1;\r\n//           hi0 = hi1;\r\n//           return dimension;\r\n//         }\r\n  \r\n//         var i,\r\n//             j,\r\n//             k,\r\n//             added = [],\r\n//             removed = [];\r\n  \r\n//         // Fast incremental update based on previous lo index.\r\n//         if (lo1 < lo0) {\r\n//           for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\r\n//             filters[k = index[i]] ^= one;\r\n//             added.push(k);\r\n//           }\r\n//         } else if (lo1 > lo0) {\r\n//           for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\r\n//             filters[k = index[i]] ^= one;\r\n//             removed.push(k);\r\n//           }\r\n//         }\r\n  \r\n//         // Fast incremental update based on previous hi index.\r\n//         if (hi1 > hi0) {\r\n//           for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\r\n//             filters[k = index[i]] ^= one;\r\n//             added.push(k);\r\n//           }\r\n//         } else if (hi1 < hi0) {\r\n//           for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\r\n//             filters[k = index[i]] ^= one;\r\n//             removed.push(k);\r\n//           }\r\n//         }\r\n  \r\n//         lo0 = lo1;\r\n//         hi0 = hi1;\r\n//         filterListeners.forEach(function(l) { l(one, added, removed); });\r\n//         return dimension;\r\n//       }\r\n  \r\n//       // Filters this dimension using the specified range, value, or null.\r\n//       // If the range is null, this is equivalent to filterAll.\r\n//       // If the range is an array, this is equivalent to filterRange.\r\n//       // Otherwise, this is equivalent to filterExact.\r\n//       function filter(range) {\r\n//         return range == null\r\n//             ? filterAll() : Array.isArray(range)\r\n//             ? filterRange(range) : typeof range === \"function\"\r\n//             ? filterFunction(range)\r\n//             : filterExact(range);\r\n//       }\r\n  \r\n//       // Filters this dimension to select the exact value.\r\n//       function filterExact(value) {\r\n//         return filterIndexBounds((refilter = crossfilter_filterExact(bisect, value))(values));\r\n//       }\r\n  \r\n//       // Filters this dimension to select the specified range [lo, hi].\r\n//       // The lower bound is inclusive, and the upper bound is exclusive.\r\n//       function filterRange(range) {\r\n//         return filterIndexBounds((refilter = crossfilter_filterRange(bisect, range))(values));\r\n//       }\r\n  \r\n//       // Clears any filters on this dimension.\r\n//       function filterAll() {\r\n//         return filterIndexBounds((refilter = crossfilter_filterAll)(values));\r\n//       }\r\n  \r\n//       // Filters this dimension using an arbitrary function.\r\n//       function filterFunction(f) {\r\n//         refilter = crossfilter_filterAll;\r\n  \r\n//         filterIndexFunction(refilterFunction = f);\r\n  \r\n//         lo0 = 0;\r\n//         hi0 = n;\r\n  \r\n//         return dimension;\r\n//       }\r\n  \r\n//       function filterIndexFunction(f) {\r\n//         var i,\r\n//             k,\r\n//             x,\r\n//             added = [],\r\n//             removed = [];\r\n  \r\n//         for (i = 0; i < n; ++i) {\r\n//           if (!(filters[k = index[i]] & one) ^ !!(x = f(values[i], i))) {\r\n//             if (x) filters[k] &= zero, added.push(k);\r\n//             else filters[k] |= one, removed.push(k);\r\n//           }\r\n//         }\r\n//         filterListeners.forEach(function(l) { l(one, added, removed); });\r\n//       }\r\n  \r\n//       // Returns the top K selected records based on this dimension's order.\r\n//       // Note: observes this dimension's filter, unlike group and groupAll.\r\n//       function top(k) {\r\n//         var array = [],\r\n//             i = hi0,\r\n//             j;\r\n  \r\n//         while (--i >= lo0 && k > 0) {\r\n//           if (!filters[j = index[i]]) {\r\n//             array.push(data[j]);\r\n//             --k;\r\n//           }\r\n//         }\r\n  \r\n//         return array;\r\n//       }\r\n  \r\n//       // Returns the bottom K selected records based on this dimension's order.\r\n//       // Note: observes this dimension's filter, unlike group and groupAll.\r\n//       function bottom(k) {\r\n//         var array = [],\r\n//             i = lo0,\r\n//             j;\r\n  \r\n//         while (i < hi0 && k > 0) {\r\n//           if (!filters[j = index[i]]) {\r\n//             array.push(data[j]);\r\n//             --k;\r\n//           }\r\n//           i++;\r\n//         }\r\n  \r\n//         return array;\r\n//       }\r\n  \r\n//       // Adds a new group to this dimension, using the specified key function.\r\n//       function group(key) {\r\n//         var group = {\r\n//           top: top,\r\n//           all: all,\r\n//           reduce: reduce,\r\n//           reduceCount: reduceCount,\r\n//           reduceSum: reduceSum,\r\n//           order: order,\r\n//           orderNatural: orderNatural,\r\n//           size: size,\r\n//           dispose: dispose,\r\n//           remove: dispose // for backwards-compatibility\r\n//         };\r\n  \r\n//         // Ensure that this group will be removed when the dimension is removed.\r\n//         dimensionGroups.push(group);\r\n  \r\n//         var groups, // array of {key, value}\r\n//             groupIndex, // object id ↦ group id\r\n//             groupWidth = 8,\r\n//             groupCapacity = crossfilter_capacity(groupWidth),\r\n//             k = 0, // cardinality\r\n//             select,\r\n//             heap,\r\n//             reduceAdd,\r\n//             reduceRemove,\r\n//             reduceInitial,\r\n//             update = crossfilter_null,\r\n//             reset = crossfilter_null,\r\n//             resetNeeded = true,\r\n//             groupAll = key === crossfilter_null;\r\n  \r\n//         if (arguments.length < 1) key = crossfilter_identity;\r\n  \r\n//         // The group listens to the crossfilter for when any dimension changes, so\r\n//         // that it can update the associated reduce values. It must also listen to\r\n//         // the parent dimension for when data is added, and compute new keys.\r\n//         filterListeners.push(update);\r\n//         indexListeners.push(add);\r\n//         removeDataListeners.push(removeData);\r\n  \r\n//         // Incorporate any existing data into the grouping.\r\n//         add(values, index, 0, n);\r\n  \r\n//         // Incorporates the specified new values into this group.\r\n//         // This function is responsible for updating groups and groupIndex.\r\n//         function add(newValues, newIndex, n0, n1) {\r\n//           var oldGroups = groups,\r\n//               reIndex = crossfilter_index(k, groupCapacity),\r\n//               add = reduceAdd,\r\n//               initial = reduceInitial,\r\n//               k0 = k, // old cardinality\r\n//               i0 = 0, // index of old group\r\n//               i1 = 0, // index of new record\r\n//               j, // object id\r\n//               g0, // old group\r\n//               x0, // old key\r\n//               x1, // new key\r\n//               g, // group to add\r\n//               x; // key of group to add\r\n  \r\n//           // If a reset is needed, we don't need to update the reduce values.\r\n//           if (resetNeeded) add = initial = crossfilter_null;\r\n  \r\n//           // Reset the new groups (k is a lower bound).\r\n//           // Also, make sure that groupIndex exists and is long enough.\r\n//           groups = new Array(k), k = 0;\r\n//           groupIndex = k0 > 1 ? crossfilter_arrayLengthen(groupIndex, n) : crossfilter_index(n, groupCapacity);\r\n  \r\n//           // Get the first old key (x0 of g0), if it exists.\r\n//           if (k0) x0 = (g0 = oldGroups[0]).key;\r\n  \r\n//           // Find the first new key (x1), skipping NaN keys.\r\n//           while (i1 < n1 && !((x1 = key(newValues[i1])) >= x1)) ++i1;\r\n  \r\n//           // While new keys remain…\r\n//           while (i1 < n1) {\r\n  \r\n//             // Determine the lesser of the two current keys; new and old.\r\n//             // If there are no old keys remaining, then always add the new key.\r\n//             if (g0 && x0 <= x1) {\r\n//               g = g0, x = x0;\r\n  \r\n//               // Record the new index of the old group.\r\n//               reIndex[i0] = k;\r\n  \r\n//               // Retrieve the next old key.\r\n//               if (g0 = oldGroups[++i0]) x0 = g0.key;\r\n//             } else {\r\n//               g = {key: x1, value: initial()}, x = x1;\r\n//             }\r\n  \r\n//             // Add the lesser group.\r\n//             groups[k] = g;\r\n  \r\n//             // Add any selected records belonging to the added group, while\r\n//             // advancing the new key and populating the associated group index.\r\n//             while (!(x1 > x)) {\r\n//               groupIndex[j = newIndex[i1] + n0] = k;\r\n//               if (!(filters[j] & zero)) g.value = add(g.value, data[j]);\r\n//               if (++i1 >= n1) break;\r\n//               x1 = key(newValues[i1]);\r\n//             }\r\n  \r\n//             groupIncrement();\r\n//           }\r\n  \r\n//           // Add any remaining old groups that were greater than all new keys.\r\n//           // No incremental reduce is needed; these groups have no new records.\r\n//           // Also record the new index of the old group.\r\n//           while (i0 < k0) {\r\n//             groups[reIndex[i0] = k] = oldGroups[i0++];\r\n//             groupIncrement();\r\n//           }\r\n  \r\n//           // If we added any new groups before any old groups,\r\n//           // update the group index of all the old records.\r\n//           if (k > i0) for (i0 = 0; i0 < n0; ++i0) {\r\n//             groupIndex[i0] = reIndex[groupIndex[i0]];\r\n//           }\r\n  \r\n//           // Modify the update and reset behavior based on the cardinality.\r\n//           // If the cardinality is less than or equal to one, then the groupIndex\r\n//           // is not needed. If the cardinality is zero, then there are no records\r\n//           // and therefore no groups to update or reset. Note that we also must\r\n//           // change the registered listener to point to the new method.\r\n//           j = filterListeners.indexOf(update);\r\n//           if (k > 1) {\r\n//             update = updateMany;\r\n//             reset = resetMany;\r\n//           } else {\r\n//             if (!k && groupAll) {\r\n//               k = 1;\r\n//               groups = [{key: null, value: initial()}];\r\n//             }\r\n//             if (k === 1) {\r\n//               update = updateOne;\r\n//               reset = resetOne;\r\n//             } else {\r\n//               update = crossfilter_null;\r\n//               reset = crossfilter_null;\r\n//             }\r\n//             groupIndex = null;\r\n//           }\r\n//           filterListeners[j] = update;\r\n  \r\n//           // Count the number of added groups,\r\n//           // and widen the group index as needed.\r\n//           function groupIncrement() {\r\n//             if (++k === groupCapacity) {\r\n//               reIndex = crossfilter_arrayWiden(reIndex, groupWidth <<= 1);\r\n//               groupIndex = crossfilter_arrayWiden(groupIndex, groupWidth);\r\n//               groupCapacity = crossfilter_capacity(groupWidth);\r\n//             }\r\n//           }\r\n//         }\r\n  \r\n//         function removeData() {\r\n//           if (k > 1) {\r\n//             var oldK = k,\r\n//                 oldGroups = groups,\r\n//                 seenGroups = crossfilter_index(oldK, oldK);\r\n  \r\n//             // Filter out non-matches by copying matching group index entries to\r\n//             // the beginning of the array.\r\n//             for (var i = 0, j = 0; i < n; ++i) {\r\n//               if (filters[i]) {\r\n//                 seenGroups[groupIndex[j] = groupIndex[i]] = 1;\r\n//                 ++j;\r\n//               }\r\n//             }\r\n  \r\n//             // Reassemble groups including only those groups that were referred\r\n//             // to by matching group index entries.  Note the new group index in\r\n//             // seenGroups.\r\n//             groups = [], k = 0;\r\n//             for (i = 0; i < oldK; ++i) {\r\n//               if (seenGroups[i]) {\r\n//                 seenGroups[i] = k++;\r\n//                 groups.push(oldGroups[i]);\r\n//               }\r\n//             }\r\n  \r\n//             if (k > 1) {\r\n//               // Reindex the group index using seenGroups to find the new index.\r\n//               for (var i = 0; i < j; ++i) groupIndex[i] = seenGroups[groupIndex[i]];\r\n//             } else {\r\n//               groupIndex = null;\r\n//             }\r\n//             filterListeners[filterListeners.indexOf(update)] = k > 1\r\n//                 ? (reset = resetMany, update = updateMany)\r\n//                 : k === 1 ? (reset = resetOne, update = updateOne)\r\n//                 : reset = update = crossfilter_null;\r\n//           } else if (k === 1) {\r\n//             if (groupAll) return;\r\n//             for (var i = 0; i < n; ++i) if (filters[i]) return;\r\n//             groups = [], k = 0;\r\n//             filterListeners[filterListeners.indexOf(update)] =\r\n//             update = reset = crossfilter_null;\r\n//           }\r\n//         }\r\n  \r\n//         // Reduces the specified selected or deselected records.\r\n//         // This function is only used when the cardinality is greater than 1.\r\n//         function updateMany(filterOne, added, removed) {\r\n//           if (filterOne === one || resetNeeded) return;\r\n  \r\n//           var i,\r\n//               k,\r\n//               n,\r\n//               g;\r\n  \r\n//           // Add the added values.\r\n//           for (i = 0, n = added.length; i < n; ++i) {\r\n//             if (!(filters[k = added[i]] & zero)) {\r\n//               g = groups[groupIndex[k]];\r\n//               g.value = reduceAdd(g.value, data[k]);\r\n//             }\r\n//           }\r\n  \r\n//           // Remove the removed values.\r\n//           for (i = 0, n = removed.length; i < n; ++i) {\r\n//             if ((filters[k = removed[i]] & zero) === filterOne) {\r\n//               g = groups[groupIndex[k]];\r\n//               g.value = reduceRemove(g.value, data[k]);\r\n//             }\r\n//           }\r\n//         }\r\n  \r\n//         // Reduces the specified selected or deselected records.\r\n//         // This function is only used when the cardinality is 1.\r\n//         function updateOne(filterOne, added, removed) {\r\n//           if (filterOne === one || resetNeeded) return;\r\n  \r\n//           var i,\r\n//               k,\r\n//               n,\r\n//               g = groups[0];\r\n  \r\n//           // Add the added values.\r\n//           for (i = 0, n = added.length; i < n; ++i) {\r\n//             if (!(filters[k = added[i]] & zero)) {\r\n//               g.value = reduceAdd(g.value, data[k]);\r\n//             }\r\n//           }\r\n  \r\n//           // Remove the removed values.\r\n//           for (i = 0, n = removed.length; i < n; ++i) {\r\n//             if ((filters[k = removed[i]] & zero) === filterOne) {\r\n//               g.value = reduceRemove(g.value, data[k]);\r\n//             }\r\n//           }\r\n//         }\r\n  \r\n//         // Recomputes the group reduce values from scratch.\r\n//         // This function is only used when the cardinality is greater than 1.\r\n//         function resetMany() {\r\n//           var i,\r\n//               g;\r\n  \r\n//           // Reset all group values.\r\n//           for (i = 0; i < k; ++i) {\r\n//             groups[i].value = reduceInitial();\r\n//           }\r\n  \r\n//           // Add any selected records.\r\n//           for (i = 0; i < n; ++i) {\r\n//             if (!(filters[i] & zero)) {\r\n//               g = groups[groupIndex[i]];\r\n//               g.value = reduceAdd(g.value, data[i]);\r\n//             }\r\n//           }\r\n//         }\r\n  \r\n//         // Recomputes the group reduce values from scratch.\r\n//         // This function is only used when the cardinality is 1.\r\n//         function resetOne() {\r\n//           var i,\r\n//               g = groups[0];\r\n  \r\n//           // Reset the singleton group values.\r\n//           g.value = reduceInitial();\r\n  \r\n//           // Add any selected records.\r\n//           for (i = 0; i < n; ++i) {\r\n//             if (!(filters[i] & zero)) {\r\n//               g.value = reduceAdd(g.value, data[i]);\r\n//             }\r\n//           }\r\n//         }\r\n  \r\n//         // Returns the array of group values, in the dimension's natural order.\r\n//         function all() {\r\n//           if (resetNeeded) reset(), resetNeeded = false;\r\n//           return groups;\r\n//         }\r\n  \r\n//         // Returns a new array containing the top K group values, in reduce order.\r\n//         function top(k) {\r\n//           var top = select(all(), 0, groups.length, k);\r\n//           return heap.sort(top, 0, top.length);\r\n//         }\r\n  \r\n//         // Sets the reduce behavior for this group to use the specified functions.\r\n//         // This method lazily recomputes the reduce values, waiting until needed.\r\n//         function reduce(add, remove, initial) {\r\n//           reduceAdd = add;\r\n//           reduceRemove = remove;\r\n//           reduceInitial = initial;\r\n//           resetNeeded = true;\r\n//           return group;\r\n//         }\r\n  \r\n//         // A convenience method for reducing by count.\r\n//         function reduceCount() {\r\n//           return reduce(crossfilter_reduceIncrement, crossfilter_reduceDecrement, crossfilter_zero);\r\n//         }\r\n  \r\n//         // A convenience method for reducing by sum(value).\r\n//         function reduceSum(value) {\r\n//           return reduce(crossfilter_reduceAdd(value), crossfilter_reduceSubtract(value), crossfilter_zero);\r\n//         }\r\n  \r\n//         // Sets the reduce order, using the specified accessor.\r\n//         function order(value) {\r\n//           select = heapselect_by(valueOf);\r\n//           heap = heap_by(valueOf);\r\n//           function valueOf(d) { return value(d.value); }\r\n//           return group;\r\n//         }\r\n  \r\n//         // A convenience method for natural ordering by reduce value.\r\n//         function orderNatural() {\r\n//           return order(crossfilter_identity);\r\n//         }\r\n  \r\n//         // Returns the cardinality of this group, irrespective of any filters.\r\n//         function size() {\r\n//           return k;\r\n//         }\r\n  \r\n//         // Removes this group and associated event listeners.\r\n//         function dispose() {\r\n//           var i = filterListeners.indexOf(update);\r\n//           if (i >= 0) filterListeners.splice(i, 1);\r\n//           i = indexListeners.indexOf(add);\r\n//           if (i >= 0) indexListeners.splice(i, 1);\r\n//           i = removeDataListeners.indexOf(removeData);\r\n//           if (i >= 0) removeDataListeners.splice(i, 1);\r\n//           return group;\r\n//         }\r\n  \r\n//         return reduceCount().orderNatural();\r\n//       }\r\n  \r\n//       // A convenience function for generating a singleton group.\r\n//       function groupAll() {\r\n//         var g = group(crossfilter_null), all = g.all;\r\n//         delete g.all;\r\n//         delete g.top;\r\n//         delete g.order;\r\n//         delete g.orderNatural;\r\n//         delete g.size;\r\n//         g.value = function() { return all()[0].value; };\r\n//         return g;\r\n//       }\r\n  \r\n//       // Removes this dimension and associated groups and event listeners.\r\n//       function dispose() {\r\n//         dimensionGroups.forEach(function(group) { group.dispose(); });\r\n//         var i = dataListeners.indexOf(preAdd);\r\n//         if (i >= 0) dataListeners.splice(i, 1);\r\n//         i = dataListeners.indexOf(postAdd);\r\n//         if (i >= 0) dataListeners.splice(i, 1);\r\n//         i = removeDataListeners.indexOf(removeData);\r\n//         if (i >= 0) removeDataListeners.splice(i, 1);\r\n//         m &= zero;\r\n//         return filterAll();\r\n//       }\r\n  \r\n//       return dimension;\r\n//     }\r\n  \r\n//     // A convenience method for groupAll on a dummy dimension.\r\n//     // This implementation can be optimized since it always has cardinality 1.\r\n//     function groupAll() {\r\n//       var group = {\r\n//         reduce: reduce,\r\n//         reduceCount: reduceCount,\r\n//         reduceSum: reduceSum,\r\n//         value: value,\r\n//         dispose: dispose,\r\n//         remove: dispose // for backwards-compatibility\r\n//       };\r\n  \r\n//       var reduceValue,\r\n//           reduceAdd,\r\n//           reduceRemove,\r\n//           reduceInitial,\r\n//           resetNeeded = true;\r\n  \r\n//       // The group listens to the crossfilter for when any dimension changes, so\r\n//       // that it can update the reduce value. It must also listen to the parent\r\n//       // dimension for when data is added.\r\n//       filterListeners.push(update);\r\n//       dataListeners.push(add);\r\n  \r\n//       // For consistency; actually a no-op since resetNeeded is true.\r\n//       add(data, 0, n);\r\n  \r\n//       // Incorporates the specified new values into this group.\r\n//       function add(newData, n0) {\r\n//         var i;\r\n  \r\n//         if (resetNeeded) return;\r\n  \r\n//         // Add the added values.\r\n//         for (i = n0; i < n; ++i) {\r\n//           if (!filters[i]) {\r\n//             reduceValue = reduceAdd(reduceValue, data[i]);\r\n//           }\r\n//         }\r\n//       }\r\n  \r\n//       // Reduces the specified selected or deselected records.\r\n//       function update(filterOne, added, removed) {\r\n//         var i,\r\n//             k,\r\n//             n;\r\n  \r\n//         if (resetNeeded) return;\r\n  \r\n//         // Add the added values.\r\n//         for (i = 0, n = added.length; i < n; ++i) {\r\n//           if (!filters[k = added[i]]) {\r\n//             reduceValue = reduceAdd(reduceValue, data[k]);\r\n//           }\r\n//         }\r\n  \r\n//         // Remove the removed values.\r\n//         for (i = 0, n = removed.length; i < n; ++i) {\r\n//           if (filters[k = removed[i]] === filterOne) {\r\n//             reduceValue = reduceRemove(reduceValue, data[k]);\r\n//           }\r\n//         }\r\n//       }\r\n  \r\n//       // Recomputes the group reduce value from scratch.\r\n//       function reset() {\r\n//         var i;\r\n  \r\n//         reduceValue = reduceInitial();\r\n  \r\n//         for (i = 0; i < n; ++i) {\r\n//           if (!filters[i]) {\r\n//             reduceValue = reduceAdd(reduceValue, data[i]);\r\n//           }\r\n//         }\r\n//       }\r\n  \r\n//       // Sets the reduce behavior for this group to use the specified functions.\r\n//       // This method lazily recomputes the reduce value, waiting until needed.\r\n//       function reduce(add, remove, initial) {\r\n//         reduceAdd = add;\r\n//         reduceRemove = remove;\r\n//         reduceInitial = initial;\r\n//         resetNeeded = true;\r\n//         return group;\r\n//       }\r\n  \r\n//       // A convenience method for reducing by count.\r\n//       function reduceCount() {\r\n//         return reduce(crossfilter_reduceIncrement, crossfilter_reduceDecrement, crossfilter_zero);\r\n//       }\r\n  \r\n//       // A convenience method for reducing by sum(value).\r\n//       function reduceSum(value) {\r\n//         return reduce(crossfilter_reduceAdd(value), crossfilter_reduceSubtract(value), crossfilter_zero);\r\n//       }\r\n  \r\n//       // Returns the computed reduce value.\r\n//       function value() {\r\n//         if (resetNeeded) reset(), resetNeeded = false;\r\n//         return reduceValue;\r\n//       }\r\n  \r\n//       // Removes this group and associated event listeners.\r\n//       function dispose() {\r\n//         var i = filterListeners.indexOf(update);\r\n//         if (i >= 0) filterListeners.splice(i);\r\n//         i = dataListeners.indexOf(add);\r\n//         if (i >= 0) dataListeners.splice(i);\r\n//         return group;\r\n//       }\r\n  \r\n//       return reduceCount();\r\n//     }\r\n  \r\n//     // Returns the number of records in this crossfilter, irrespective of any filters.\r\n//     function size() {\r\n//       return n;\r\n//     }\r\n  \r\n//     return arguments.length\r\n//         ? add(arguments[0])\r\n//         : crossfilter;\r\n//   }\r\n  \r\n//   // Returns an array of size n, big enough to store ids up to m.\r\n//   function crossfilter_index(n, m) {\r\n//     return (m < 0x101\r\n//         ? crossfilter_array8 : m < 0x10001\r\n//         ? crossfilter_array16\r\n//         : crossfilter_array32)(n);\r\n//   }\r\n  \r\n//   // Constructs a new array of size n, with sequential values from 0 to n - 1.\r\n//   function crossfilter_range(n) {\r\n//     var range = crossfilter_index(n, n);\r\n//     for (var i = -1; ++i < n;) range[i] = i;\r\n//     return range;\r\n//   }\r\n  \r\n//   function crossfilter_capacity(w) {\r\n//     return w === 8\r\n//         ? 0x100 : w === 16\r\n//         ? 0x10000\r\n//         : 0x100000000;\r\n//   }\r\n//   })(typeof exports !== 'undefined' && exports || this);"]}